<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a 
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-3.xsd">

    <!--
    样机订单：
    Test machine orders：
    1、供应商样机直送客户
    2、供应商样机先送公司，再送客户
    3、公司样机送客户

    -->

    <!-- ========== TestMachineOrder Header  ========== -->

    <service verb="create" noun="TestMachineOrder">
        <description>
            Create an TestMachineOrder (testMachineOrderHeader ).
            All parameters are optional so that this can be called transparently to create a shell/empty order.
        </description>
        <in-parameters>
            <auto-parameters entity-name="beiyelin.testmachine.TestMachineOrderHeader" include="nonpk">
                <exclude field-name="grandTotal"/>
            </auto-parameters>

            <parameter name="statusId" default-value="TMOHSOpen">
                <description>The initial statusId for both header and part.</description>
            </parameter>
            <parameter name="requestDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="requestPartyId" default="ec.user.userAccount?.partyId"/>
            <parameter name="currencyUomId">
                <description>Defaults to PartyAcctgPreference.baseCurrencyUomId for whichever
                    Party (customer or vendor) is an internal organization with an accounting preference record.
                </description>
            </parameter>
            <parameter name="orderRevision" type="Integer" default="1"/>
        </in-parameters>
        <out-parameters>
            <parameter name="testMachineOrderId" required="true"/>
        </out-parameters>
        <actions>

            <if condition="!currencyUomId">
                <if condition="customerPartyId">
                    <service-call name="mantle.ledger.LedgerServices.find#PartyAcctgPreference" out-map="context"
                                  in-map="[organizationPartyId:customerPartyId]"/>
                </if>
                <if condition="!partyAcctgPreference &amp;&amp; vendorPartyId">
                    <service-call name="mantle.ledger.LedgerServices.find#PartyAcctgPreference" out-map="context"
                                  in-map="[organizationPartyId:vendorPartyId]"/>
                </if>
                <set field="currencyUomId" from="partyAcctgPreference?.baseCurrencyUomId"/>
            </if>
            <!-- MAYBE: get this from configuration somewhere, needed beyond PartyAcctgPreference? -->
            <if condition="!currencyUomId">
                <set field="currencyUomId" value="RMB"/>
            </if>



            <if condition="customerPartyId">
                <!-- If customer is internal org and there is a facility get default ship dest contact info -->
                <entity-find entity-name="mantle.party.PartyRole" list="custOrgInternalList">
                    <econdition field-name="partyId" from="customerPartyId"/>
                    <econdition field-name="roleTypeId" value="OrgInternal"/>
                </entity-find>
                <if condition="custOrgInternalList">
                    <service-call name="mantle.facility.ContactServices.get#FacilityDefaultShipDest"
                                  in-map="context" out-map="context"/>
                </if>

                <!-- if customer Party.shippingInstructions populate if none specified -->
                <if condition="!shippingInstructions">
                    <entity-find-one entity-name="mantle.party.Party" value-field="customerParty">
                        <field-map field-name="partyId" from="customerPartyId"/>
                    </entity-find-one>
                    <set field="shippingInstructions" from="customerParty?.shippingInstructions"/>
                </if>

            </if>

            <service-call name="create#beiyelin.testmachine.TestMachineOrderHeader" in-map="context" out-map="context"/>

        </actions>
    </service>
    <service verb="update" noun="TestMachineOrderHeader">
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <auto-parameters entity-name="beiyelin.testmachine.TestMachineOrderHeader" include="nonpk">
                <exclude field-name="approvedDate"/>
                <exclude field-name="placedDate"/>
                <exclude field-name="completedDate"/>
                <exclude field-name="statusId"/>
                <exclude field-name="orderRevision"/>
                <exclude field-name="grandTotal"/>
            </auto-parameters>
<!--            <parameter name="testMachineOrderName"/>-->

        </in-parameters>
        <actions>
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader"
                             value-field="testMachineOrderHeader"/>
            <entity-set value-field="testMachineOrderHeader" include="nonpk" set-if-empty="true"/>
            <set field="testMachineOrderHeader.orderRevision" from="testMachineOrderHeader.orderRevision + 1"/>
            <entity-update value-field="testMachineOrderHeader"/>

        </actions>
    </service>

    <service verb="delete" noun="TestMachineOrder">
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader"
                             value-field="testMachineOrderHeader"/>
            <if condition="testMachineOrderHeader.statusId != 'TMOHSOpen'">
                <return error="true" message="Cannot deleted the TestMachineOrder:${testMachineOrderHeader.testMachineOrderId} which status is ${testMachineOrderHeader.statusId }"/>
            </if>
<!--            delete related entity-->
            <entity-delete-by-condition entity-name="beiyelin.testmachine.TestMachineOrderCommunicationEvent">
                <econdition field-name="testMachineOrderId" from="testMachineOrderHeader.testMachineOrderId"/>
            </entity-delete-by-condition>

            <entity-delete-by-condition entity-name="beiyelin.testmachine.TestMachineOrderEmailMessage">
                <econdition field-name="testMachineOrderId" from="testMachineOrderHeader.testMachineOrderId"/>
            </entity-delete-by-condition>

            <entity-delete-by-condition entity-name="beiyelin.testmachine.TestMachineOrderParty">
                <econdition field-name="testMachineOrderId" from="testMachineOrderHeader.testMachineOrderId"/>
            </entity-delete-by-condition>

            <entity-delete-by-condition entity-name="beiyelin.testmachine.TestMachineOrderNote">
                <econdition field-name="testMachineOrderId" from="testMachineOrderHeader.testMachineOrderId"/>
            </entity-delete-by-condition>

            <entity-delete-by-condition entity-name="beiyelin.testmachine.TestMachineOrderItem">
                <econdition field-name="testMachineOrderId" from="testMachineOrderHeader.testMachineOrderId"/>
            </entity-delete-by-condition>

            <entity-delete value-field="testMachineOrderHeader"/>

        </actions>
    </service>
    <!-- ======================================== -->
    <!-- ========== OrderItem Services ========== -->
    <!-- ======================================== -->

<!-- TODO：to be deleted
    <service verb="get" noun="TestMachineOrderItemTotal">
        <in-parameters>
            <parameter name="testMachineOrderItem" type="EntityValue">
                <description>Can be a view-entity with OrderItem and at least
                    the fields testMachineOrderId, testMachineOrderItemSeqId, unitPrice, quantity, selectedAmount.
                </description>
            </parameter>
            <parameter name="getChildrenTotals" type="Boolean" default="false"/>
        </in-parameters>
        <out-parameters>
            <parameter name="combinedAmount" type="BigDecimal">
                <description>unitPrice (default 0.0) * selectedAmount (default 1.0)</description>
            </parameter>
            <parameter name="combinedQuantity" type="BigDecimal">
                <description>quantity (1.0 if null) * selectedAmount (default 1.0)</description>
            </parameter>
            <parameter name="itemTotal" type="BigDecimal"/>
            <parameter name="childrenTotal" type="BigDecimal"/>
            <parameter name="itemPlusChildrenTotal" type="BigDecimal"/>
            <parameter name="childItemCount" type="Integer"/>
            <parameter name="childOrderItemList" type="List">
                <parameter name="childOrderItem" type="Map"/>
            </parameter>
        </out-parameters>
        <actions>
            &lt;!&ndash; for return value, unitPrice * selectedAmount &ndash;&gt;
            <set field="combinedAmount"
                 from="((testMachineOrderItem.unitPrice ?: 0.0) * (testMachineOrderItem.selectedAmount ?: 1.0))"/>

            <set field="combinedQuantity"
                 from="(testMachineOrderItem.quantity != null ? testMachineOrderItem.quantity : 1.0) * (testMachineOrderItem.selectedAmount ?: 1.0)"/>
            &lt;!&ndash; NOTE: also a sales/VAT tax calculation concern on item vs invoice level, but using 2 digits so consistent across order, invoice, GL TX entry
                (tax should generally be calculated to 3 digits on the item level then summed and rounded to 2 digits to get a tax total) &ndash;&gt;
            &lt;!&ndash; NOTE: CurrencyRoundingMarker scale here may vary by currency, make configurable &ndash;&gt;
            <set field="itemTotal"
                 from="(combinedQuantity * (testMachineOrderItem.unitPrice as BigDecimal ?: 0.0)).setScale(2, BigDecimal.ROUND_HALF_UP)"/>
            <if condition="getChildrenTotals">
                &lt;!&ndash; recursively get total of child OrderItems &ndash;&gt;
                &lt;!&ndash; don't use relationship, allow view-entities, etc <entity-find-related value-field="testMachineOrderItem" relationship-name="Child#OrderItem" list="childOrderItemList"/> &ndash;&gt;
                <entity-find entity-name="beiyelin.testmachine.TestMachineOrderItem" list="childOrderItemList">
                    <econdition field-name="testMachineOrderId" from="testMachineOrderItem.testMachineOrderId"/>
                    <econdition field-name="parentItemSeqId" from="testMachineOrderItem.testMachineOrderItemSeqId"/>
                </entity-find>
                <set field="childrenTotal" from="0.0"/>
                <set field="hasPromo" from="false"/>
                <set field="promoQuantityUsed" from="0.0"/>
                <iterate list="childOrderItemList" entry="childOrderItem">
                    <service-call name="beiyelin.testmachine.TestMachineOrderServices.get#TestMachineOrderItemTotal"
                                  out-map="getOitResult" out-map-add-to-existing="false"
                                  in-map="[testMachineOrderItem:childOrderItem, getChildrenTotals:true]"/>
                    <set field="childrenTotal" from="childrenTotal + getOitResult.itemPlusChildrenTotal"/>


                </iterate>
                <set field="itemPlusChildrenTotal" from="itemTotal + childrenTotal"/>
                <set field="childItemCount" from="childOrderItemList.size()"/>
            </if>
        </actions>
    </service>
-->

    <service verb="create" noun="TestMachineOrderItem">
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <auto-parameters entity-name="beiyelin.testmachine.TestMachineOrderItem" include="nonpk"/>
            <parameter name="quantity" type="BigDecimal" default="1"/>
        </in-parameters>
        <out-parameters>
            <parameter name="testMachineOrderItemSeqId" required="true"/>
        </out-parameters>
        <actions>

            <if condition="productId">
                <entity-find-one entity-name="mantle.product.Product" value-field="product" cache="true"/>
                <if condition="product == null">
                    <return error="true" message="Product ${productId} not found"/>
                </if>
                <if condition="product.productTypeEnumId == 'PtVirtual'">
                    <return error="true"
                            message="Product ${productId} is a Virtual product and may not be used on an TestMachineOrder"/>
                </if>
                <!-- set some product item defaults -->
                <if condition="product?.amountRequire == 'Y' ">
                    <return error="true" message="Product ${productId} requires a selected amount"/>
                </if>
                <if condition="!itemDescription">
                    <set field="itemDescription" from="product?.productName"/>
                </if>
                <if condition="!quantityUomId">
                    <set field="quantityUomId" from="product?.amountUomId"/>
                </if>

            </if>

            <!--            设置金额-->
            <if condition="unitPrice">
                <then>
                    <set field="amount" from="quantity * unitPrice"/>
                </then>
                <else>
                    <set field="amount" from="0.0"/>
                </else>
            </if>

            <service-call name="create#beiyelin.testmachine.TestMachineOrderItem" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="update" noun="TestMachineOrderItem">
        <in-parameters>
            <auto-parameters include="pk" required="true"/>
            <auto-parameters include="nonpk"/>

        </in-parameters>
        <actions>
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderItem" value-field="testMachineOrderItem"
                             for-update="true"/>
            <set field="productId" from="productId ?: testMachineOrderItem.productId"/>
            <set field="quantity" from="quantity != null ? quantity : testMachineOrderItem.quantity"/>

            <if condition="productId">
                <if condition="productId != testMachineOrderItem.productId">
                    <entity-find-one entity-name="mantle.product.Product" value-field="product" cache="true"/>
                    <if condition="product == null">
                        <return error="true" message="Product ${productId} not found"/>
                    </if>
                    <if condition="product.productTypeEnumId == 'PtVirtual'">
                        <return error="true"
                                message="Product ${productId} is a Virtual product and may not be used on an TestMachineOrder"/>
                    </if>
                </if>
            </if>



            <!-- on quantity changes adjust ShipmentItem/Source (only if some exist for 'open' shipments) -->
            <if condition="quantity != null &amp;&amp; quantity != testMachineOrderItem.quantity">
                <entity-find entity-name="mantle.shipment.ShipmentAndItemSource" list="shipmentItemSourceList">
                    <econdition field-name="testMachineOrderId"/>
                    <econdition field-name="testMachineOrderItemSeqId"/>
                    <econdition field-name="shipmentStatusId" operator="in" value="ShipInput,ShipScheduled"/>
                    <order-by field-name="shipmentId"/>
                </entity-find>
                <if condition="shipmentItemSourceList">
                    <set field="sourceQuantityTotal" from="0"/>
                    <iterate list="shipmentItemSourceList" entry="shipmentItemSource">
                        <set field="sourceQuantityTotal"
                             from="sourceQuantityTotal + shipmentItemSource.quantity"/>
                    </iterate>
                    <if condition="quantity &gt; sourceQuantityTotal">
                        <then>
                            <set field="quantityIncrease" from="quantity - sourceQuantityTotal"/>
                            <!-- quantity increase, we don't know which shipment it should go on so just pick the first -->
                            <set field="shipmentItemSource" from="shipmentItemSourceList[0]"/>
                            <service-call name="update#mantle.shipment.ShipmentItemSource"
                                          in-map="[shipmentItemSourceId:shipmentItemSource.shipmentItemSourceId,
                                  quantity:(shipmentItemSource.quantity + quantityIncrease),
                                  quantityNotHandled:(shipmentItemSource.quantityNotHandled + quantityIncrease)]"/>

                            <!-- also update ShipmentItem.quantity -->
                            <entity-find-one entity-name="mantle.shipment.ShipmentItem"
                                             value-field="shipmentItem">
                                <field-map field-name="shipmentId" from="shipmentItemSource.shipmentId"/>
                                <field-map field-name="productId" from="testMachineOrderItem.productId"/>
                            </entity-find-one>
                            <service-call name="update#mantle.shipment.ShipmentItem"
                                          in-map="[shipmentId:shipmentItem.shipmentId, productId:shipmentItem.productId,
                                  quantity:(shipmentItem.quantity + quantityIncrease)]"/>
                        </then>
                        <else>
                            <!-- a little more fun, deduct as available from each item in the list until all handled -->
                            <set field="quantityReduceRemaining" from="sourceQuantityTotal - quantity"/>
                            <iterate list="shipmentItemSourceList" entry="shipmentItemSource">
                                <set field="quantityReduce" from="quantityReduceRemaining &gt; shipmentItemSource.quantityNotHandled ?
                            shipmentItemSource.quantityNotHandled : quantityReduceRemaining"/>
                                <if condition="quantityReduce == 0">
                                    <break/>
                                </if>
                                <service-call name="update#mantle.shipment.ShipmentItemSource"
                                              in-map="[shipmentItemSourceId:shipmentItemSource.shipmentItemSourceId,
                                quantity:(shipmentItemSource.quantity - quantityReduce),
                                quantityNotHandled:(shipmentItemSource.quantityNotHandled - quantityReduce)]"/>
                                <set field="quantityReduceRemaining"
                                     from="quantityReduceRemaining - quantityReduce"/>

                                <!-- also update ShipmentItem.quantity -->
                                <entity-find-one entity-name="mantle.shipment.ShipmentItem"
                                                 value-field="shipmentItem">
                                    <field-map field-name="shipmentId" from="shipmentItemSource.shipmentId"/>
                                    <field-map field-name="productId" from="testMachineOrderItem.productId"/>
                                </entity-find-one>
                                <set field="newItemQuantity" from="shipmentItem.quantity &gt; quantityReduce ?
                            shipmentItem.quantity - quantityReduce : 0.0"/>
                                <service-call name="update#mantle.shipment.ShipmentItem"
                                              in-map="[shipmentId:shipmentItem.shipmentId, productId:shipmentItem.productId,
                                quantity:newItemQuantity]"/>
                            </iterate>
                        </else>
                    </if>
                </if>
            </if>

            <!--            设置金额-->
            <if condition="unitPrice">
                <then>
                    <set field="amount" from="quantity * unitPrice"/>
                </then>
                <else>
                    <set field="amount" from="0.0"/>
                </else>
            </if>

            <service-call name="update#beiyelin.testmachine.TestMachineOrderItem" in-map="context"/>
            <!-- leave this out, may be nice to have a way to easily ignore messages from a specific service call: <message>TestMachineOrder item ${testMachineOrderItemSeqId} updated</message> -->
        </actions>
    </service>
    <service verb="delete" noun="TestMachineOrderItem">
        <in-parameters>
            <auto-parameters include="pk" required="true"/>
        </in-parameters>
        <actions>

            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderItem"
                             value-field="testMachineOrderItem"/>
            <if condition="testMachineOrderItem == null">
                <return message="TestMachineOrder ${testMachineOrderId} item ${testMachineOrderItemSeqId} not found"/>
            </if>

            <!-- delete item -->
            <service-call name="delete#beiyelin.testmachine.TestMachineOrderItem" in-map="context"/>

            <!-- explicitly call handle#TestMachineOrderMajorChange to trigger promo, shipping, tax calc -->
<!--            TODO: 不一定需要这个服务了-->
<!--            <service-call name="beiyelin.testmachine.TestMachineOrderServices.handle#TestMachineOrderMajorChange"
                          in-map="[testMachineOrderId:testMachineOrderItem.testMachineOrderId]"/>-->
        </actions>
    </service>

<!--    已经不需要这个过程了-->
<!--    <service verb="recalc" noun="TestMachineOrderItemAmount">-->
<!--        <in-parameters>-->
<!--            <parameter name="testMachineOrderId" required="true"/>-->
<!--            <parameter name="testMachineOrderItemSeqId" required="true"/>-->
<!--        </in-parameters>-->
<!--        <actions>-->
<!--            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderItem" value-field="testMachineOrderItem"-->
<!--                             for-update="true"/>-->
<!--            <if condition="testMachineOrderItem.productId == null">-->
<!--                <return/>-->
<!--            </if>-->

<!--            &lt;!&ndash; Is this a product item? &ndash;&gt;-->
<!--            <entity-find entity-name="moqui.basic.EnumGroupMember" list="productItemTypeEgms" cache="true">-->
<!--                <econdition field-name="enumGroupEnumId" value="EngItemsProduct"/>-->
<!--            </entity-find>-->
<!--            <set field="productItemTypes" from="productItemTypeEgms*.enumId"/>-->
<!--            <if condition="!(testMachineOrderItem.itemTypeEnumId in productItemTypes)">-->
<!--                <return/>-->
<!--            </if>-->

<!--            &lt;!&ndash;TODO 这种计算价格的方式是否需要&ndash;&gt;-->
<!--            <service-call name="mantle.product.PriceServices.get#OrderProductPrice" out-map="priceOut"-->
<!--                          in-map="[productId:testMachineOrderItem.productId, quantity:testMachineOrderItem.quantity, testMachineOrderId:testMachineOrderId]"/>-->

<!--            <if condition="priceOut.price">-->
<!--                <then>-->
<!--                    <if condition="priceOut.price != testMachineOrderItem.unitPrice">-->
<!--                        <service-call name="update#beiyelin.testmachine.TestMachineOrderItem" in-map="[testMachineOrderId:testMachineOrderId, testMachineOrderItemSeqId:testMachineOrderItem.testMachineOrderItemSeqId,-->
<!--                        unitPrice:priceOut.price, unitListPrice:priceOut.listPrice, isModifiedPrice:'N']"/>-->
<!--                    </if>-->
<!--                </then>-->
<!--                <else>-->
<!--                    <message type="warning">No price found for Product ${testMachineOrderItem.productId} on-->
<!--                        TestMachineOrder Item ${testMachineOrderId}:${testMachineOrderItemSeqId}, not resetting-->
<!--                    </message>-->
<!--                </else>-->
<!--            </if>-->
<!--        </actions>-->
<!--    </service>-->

    <service verb="check" noun="AvailableInventory">
        <in-parameters>
            <parameter name="productId" required="true"/>
            <parameter name="quantity" type="BigDecimal" required="true"/>
            <parameter name="testMachineOrderId" required="true"/>
            <parameter name="testMachineOrderItemSeqId"/>
            <parameter name="requireInventory" type="Boolean">
                <description>If true make sure inventory is available, if false don't check.
                </description>
            </parameter>
            <parameter name="testMachineOrderHeader" type="EntityValue"/>
        </in-parameters>
        <actions>
            <!-- if available inventory not required return now -->
            <if condition="!requireInventory">
                <return/>
            </if>
            <if condition="testMachineOrderHeader == null"><entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader" value-field="testMachineOrderHeader"/></if>
            <!-- get current available inventory -->
            <service-call name="mantle.product.AssetServices.get#AvailableInventory" out-map="availOut"
                          in-map="[productId:productId, facilityId:testMachineOrderHeader.vendorFacilityId, vendorPartyId:testMachineOrderHeader.vendorPartyId,
                         customerPartyId:testMachineOrderHeader.customerPartyId]"/>
            <set field="availableToPromiseTotal" from="availOut.availableToPromiseTotal"/>
            <!-- if out of stock show one message, if insufficient available show another -->
            <if condition="availableToPromiseTotal &lt; quantity">
                <entity-find-one entity-name="mantle.product.Product" value-field="product" cache="true"/>
                <if condition="availableToPromiseTotal &lt;= 0.0">
                    <then>
                        <message public="true" type="warning">OrderInventoryNotAvailable</message>
                        <return error="true"
                                message="Inventory not available, not updating testMachineOrder ${testMachineOrderId}:${testMachineOrderItemSeqId} product ${productId} for quantity ${quantity}"/>
                    </then>
                    <else>
                        <message public="true" type="warning">OrderInventoryInsufficient</message>
                        <return error="true"
                                message="Inventory insufficient, not updating testMachineOrder ${testMachineOrderId}:${testMachineOrderItemSeqId} product ${productId} for quantity ${quantity}"/>
                    </else>
                </if>
            </if>
        </actions>
    </service>

    <service verb="add" noun="TestMachineOrderItem" authenticate="anonymous-all">
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <parameter name="productId" required="true"/>
            <auto-parameters include="nonpk"/>

            <parameter name="quantity" type="BigDecimal">
                <description>Defaults to 1 if addToQuantity=true (default)</description>
            </parameter>
            <parameter name="addToQuantity" type="Boolean" default="true">
                <description>If true add to existing quantity, if false set quantity on current item</description>
            </parameter>
            <parameter name="updateExisting" type="Boolean" default="true">
                <description>If true update existing item by productId, if false always create a new item</description>
            </parameter>
            <parameter name="requireInventory" type="Boolean">
                <description>If true make sure inventory is available, if false don't check.
                </description>
            </parameter>

        </in-parameters>
        <out-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <parameter name="testMachineOrderItemSeqId" required="true"/>
        </out-parameters>
        <actions>
            <if condition="quantity == null &amp;&amp; (addToQuantity || !updateExisting)">
                <set field="quantity" from="1.0"/>
            </if>
            <!-- handle explicit zero quantity -->
            <if condition="(quantity == null || quantity &lt;= 0) &amp;&amp; updateExisting">
                <!-- do nothing if add -->
                <if condition="addToQuantity || !testMachineOrderId">
                    <return/>
                </if>
                <return/>
            </if>
<!--            如果产品的库存类型不是库存，则返回-->
            <entity-find-one entity-name="products" value-field="curProduct"/>
            <if condition="curProduct.productTypeEnumId != 'PtAsset'">
                <return error="true" message="Product id:${productId} name:${curProduct.name} is not a Asset Goods "/>
            </if>

<!--            统一设置为样机库存-->
            <set field="assetTypeEnumId" from="AstTpTestMachine" />

            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader" value-field="testMachineOrderHeader"
                             for-update="true"/>

            <!-- find an OrderItem for the productId and increment quantity if found, otherwise create OrderItem with quantity -->
            <entity-find entity-name="beiyelin.testmachine.TestMachineOrderItem" list="testMachineOrderItemList">
                <econdition field-name="testMachineOrderId"/>
                <econdition field-name="productId"/>
                <order-by field-name="testMachineOrderItemSeqId"/>
            </entity-find>

            <if condition="testMachineOrderItemList &amp;&amp; updateExisting">
                <then>
                    <set field="testMachineOrderItem" from="testMachineOrderItemList.first"/>
                    <set field="testMachineOrderItemSeqId" from="testMachineOrderItem.testMachineOrderItemSeqId"/>
                    <set field="unitPrice" from="unitPrice != null ? unitPrice : testMachineOrderItem.unitPrice"/>
                    <set field="quantity" from="addToQuantity ? quantity + testMachineOrderItem.quantity : quantity"/>
                    <service-call name="beiyelin.testmachine.TestMachineOrderServices.update#TestMachineOrderItem"
                                  in-map="context"/>
                </then>
                <else>
                    <service-call name="beiyelin.testMachine.TestMachineOrderServices.create#TestMachineOrderItem"
                                  in-map="context"
                                  out-map="createOrderItemOut"/>
                    <set field="testMachineOrderItemSeqId" from="createOrderItemOut.testMachineOrderItemSeqId"/>
                </else>
            </if>
        </actions>
    </service>

    <service verb="update" noun="TestMachineOrderProductQuantity" authenticate="anonymous-all">
        <!-- TODO had transaction="cache" but causing issues with updating single Payment amount and sometimes part/header total when there are multiple promotions active (ie New Customer and BOGO) -->
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <parameter name="testMachineOrderItemSeqId" required="true"/>
            <parameter name="quantity" type="BigDecimal" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader" value-field="testMachineOrderHeader"
                             for-update="true"/>
            <if condition="quantity &lt;= 0">
                <service-call name="beiyelin.testmachine.TestMachineOrderServices.delete#TestMachineOrderItem"
                              in-map="[testMachineOrderId:testMachineOrderId, testMachineOrderItemSeqId:testMachineOrderItemSeqId]"/>
                <return/>
            </if>

            <service-call name="beiyelin.testmachine.TestMachineOrderServices.update#TestMachineOrderItem"
                          in-map="[testMachineOrderId:testMachineOrderId, testMachineOrderItemSeqId:testMachineOrderItemSeqId, quantity:quantity]"/>
        </actions>
    </service>
    <service verb="merge" noun="TestMachineOrderItems">
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <parameter name="fromOrderId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find entity-name="beiyelin.testmachine.TestMachineOrderItem" list="testMachineOrderItemList">
                <econdition field-name="testMachineOrderId" from="fromOrderId"/>
            </entity-find>

            <iterate list="testMachineOrderItemList" entry="testMachineOrderItem">
                <service-call name="beiyelin.testmachine.TestMachineOrderServices.add#TestMachineOrderProductQuantity"
                              in-map="[testMachineOrderId:testMachineOrderId, productId:testMachineOrderItem.productId, quantity:testMachineOrderItem.quantity]"/>
            </iterate>
        </actions>
    </service>

    <!-- ================================================== -->
    <!-- ========== TestMachineOrder Status Change Services ========== -->
    <!-- ================================================== -->

    <service verb="change" noun="TestMachineOrderStatusInterface" type="interface">
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="oldStatusId"/>
            <parameter name="statusChanged" type="Boolean"/>
        </out-parameters>
    </service>
    <service verb="update" noun="TestMachineOrderStatus">
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <parameter name="statusId" required="true"/>
            <parameter name="placedDate" type="Timestamp"/>
            <parameter name="approvedDate" type="Timestamp"/>
            <parameter name="completedDate" type="Timestamp"/>
        </in-parameters>
        <out-parameters>
            <parameter name="oldStatusId"/>
            <parameter name="statusChanged" type="Boolean"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader"
                             value-field="testMachineOrderHeader" for-update="true"/>

            <set field="updateMap" from="[testMachineOrderId:testMachineOrderId, statusId:statusId]"/>
            <if condition="placedDate != null &amp;&amp; testMachineOrderHeader.placedDate == null">
                <script>updateMap.put('placedDate', placedDate)</script>
            </if>
            <if condition="approvedDate != null &amp;&amp; testMachineOrderHeader.approvedDate == null">
                <script>updateMap.put('approvedDate', approvedDate)</script>
            </if>
            <if condition="completedDate != null &amp;&amp; testMachineOrderHeader.completedDate == null">
                <script>updateMap.put('completedDate', completedDate)</script>
            </if>
            <service-call name="update#beiyelin.testmachine.TestMachineOrderHeader" out-map="context"
                          in-map="updateMap"/>
        </actions>
    </service>
<!--    <service verb="propose" noun="TestMachineOrder">-->
<!--        <implements service="beiyelin.testmachine.TestMachineOrderServices.change#TestMachineOrderStatusInterface"/>-->
<!--        <actions>-->
<!--            <service-call name="beiyelin.testmachine.TestMachineOrderServices.update#TestMachineOrderStatus"-->
<!--                          out-map="context" in-map="context + [statusId:'OrderProposed']"/>-->
<!--        </actions>-->
<!--    </service>-->
    <service verb="place" noun="TestMachineOrder">
        <!-- this used to use transaction="cache" but with record locks (for asset reservation) it is unreliable, gets old data from the TX cache -->
        <implements service="beiyelin.testmachine.TestMachineOrderServices.change#TestMachineOrderStatusInterface"/>
        <in-parameters>
            <parameter name="placedDate" type="Timestamp" default="ec.user.nowTimestamp"/>

        </in-parameters>
        <actions>
            <service-call name="beiyelin.testmachine.TestMachineOrderServices.update#TestMachineOrderStatus"
                          out-map="context"
                          in-map="context + [statusId:'TMOHSPlaced', placedDate:placedDate]"/>

<!--            检查reservation是否完整-->

            <if condition="requireInventory">


                <if condition="testMachineOrderHeader == null">
                    <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader"
                                     value-field="testMachineOrderHeader"/>
                </if>
                <entity-find entity-name="beiyelin.testmachine.TestMachineOrderItem" list="testMachineOrderItemList">
                    <econdition field-name="testMachineOrderId"/>
                    <econdition field-name="productId" operator="is-not-null"/>
                    <!-- testMachineOrder by productId to avoid deadlocks -->
                    <order-by field-name="productId"/>
                </entity-find>

                <set field="allInventoryAvailable" from="true"/>
                <iterate list="testMachineOrderItemList" entry="testMachineOrderItem">

                    <!-- get current available inventory -->
                    <service-call name="mantle.product.AssetServices.get#AvailableInventory" out-map="availOut"
                                  in-map="[productId:productId, facilityId:testMachineOrderHeader.vendorFacilityId, vendorPartyId:testMachineOrderHeader.vendorPartyId,
                         customerPartyId:testMachineOrderHeader.customerPartyId]"/>

                    <set field="availableToPromiseTotal" from="availOut.availableToPromiseTotal"/>
                    <!-- if out of stock show one message, if insufficient available show another -->
                    <if condition="availableToPromiseTotal &lt; testMachineOrderItem.quantity">
                        <set field="allInventoryAvailable" from="false"/>
                        <if condition="availableToPromiseTotal &lt;= 0.0">
                            <then>
                                <message public="true" type="warning">OrderInventoryNotAvailable</message>
                            </then>
                            <else>
                                <message public="true" type="warning">OrderInventoryInsufficient</message>
                            </else>
                        </if>
                    </if>
                </iterate>

                <if condition="!allInventoryAvailable">
                    <!-- NOTE: return with error=true will cause TX rollback, including reservations -->
                    <return error="true"
                            message="Inventory required but not all available, not placing testMachineOrder ${testMachineOrderId}"/>
                </if>
            </if>

        </actions>
    </service>
    <service verb="approve" noun="TestMachineOrder">
        <description>For manual testMachineOrder approval</description>
        <implements service="beiyelin.testmachine.TestMachineOrderServices.change#OrderStatusInterface"/>
        <in-parameters>
            <parameter name="approvedDate" type="Timestamp" default="ec.user.nowTimestamp"/>
        </in-parameters>
        <actions>
            <service-call name="beiyelin.testmachine.TestMachineOrderServices.update#TestMachineOrderStatus"
                          out-map="context" in-map="context + [statusId:'TMOHSApproved']"/>
        </actions>
    </service>


    <service verb="isFulfilled" noun="TestMachineOrderItem">
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <parameter name="testMachineOrderItemSeqId" required="true"/>
            <!-- optional fields for efficiency, each if null will be queried -->
            <parameter name="testMachineOrderItem" type="EntityValue"/>
            <parameter name="orderSubscriptionList" type="List"/>
            <parameter name="orderWorkEffortList" type="List"/>
            <parameter name="orderAssetIssuanceList" type="List"/>
            <parameter name="orderAssetReceiptList" type="List"/>
        </in-parameters>
        <out-parameters>
            <parameter name="isFulfilled" type="Boolean"/>
        </out-parameters>
        <actions>
            <if condition="testMachineOrderItem == null">
                <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderItem"
                                 value-field="testMachineOrderItem"/>
            </if>


            <!-- set to true, if any evidence found that it is not fulfilled will set to false -->
            <set field="isFulfilled" from="true"/>
            <if condition="testMachineOrderItem.productId ">
                <then>
                    <entity-find-one entity-name="mantle.product.Product" value-field="product" cache="true">
                        <field-map field-name="productId" from="testMachineOrderItem.productId"/>
                    </entity-find-one>

<!--                    不知道Subscription有什么业务意义，暂时掩藏-->
<!--                    <if condition="orderSubscriptionList == null">-->
<!--                        <entity-find entity-name="mantle.product.subscription.Subscription"-->
<!--                                     list="orderSubscriptionList">-->
<!--                            <econdition field-name="testMachineOrderId"/>-->
<!--                            <econdition field-name="testMachineOrderItemSeqId"/>-->
<!--                        </entity-find>-->
<!--                    </if>-->
<!--                    <entity-find entity-name="mantle.product.subscription.ProductSubscriptionResource"-->
<!--                                 list="productSubscriptionResourceList" cache="true">-->
<!--                        <econdition field-name="productId" from="product.productId"/>-->
<!--                    </entity-find>-->
<!--                    <iterate list="productSubscriptionResourceList" entry="productSubscriptionResource">-->
<!--                        <filter-map-list list="orderSubscriptionList" to-list="currentSubscriptionList">-->
<!--                            <field-map field-name="testMachineOrderItemSeqId"-->
<!--                                       from="testMachineOrderItem.testMachineOrderItemSeqId"/>-->
<!--                            <field-map field-name="subscriptionResourceId"-->
<!--                                       from="productSubscriptionResource.subscriptionResourceId"/>-->
<!--                        </filter-map-list>-->
<!--                        <if condition="!currentSubscriptionList">-->
<!--                            <set field="isFulfilled" from="false"/>-->
<!--                        </if>-->
<!--                    </iterate>-->

                    <if condition="isFulfilled ">
                        <if condition="orderAssetIssuanceList == null">
                            <then>
                                <entity-find entity-name="mantle.product.issuance.AssetIssuance"
                                             list="currentAssetIssuanceList">
                                    <econdition field-name="testMachineOrderId"/>
                                    <econdition field-name="testMachineOrderItemSeqId"/>
                                </entity-find>
                            </then>
                            <else>
                                <filter-map-list list="orderAssetIssuanceList" to-list="currentAssetIssuanceList">
                                    <field-map field-name="testMachineOrderItemSeqId"/>
                                </filter-map-list>
                            </else>
                        </if>
                        <if condition="orderAssetReceiptList == null">
                            <then>
                                <entity-find entity-name="mantle.product.issuance.AssetIssuance"
                                             list="currentAssetIssuanceList">
                                    <econdition field-name="testMachineOrderId"/>
                                    <econdition field-name="testMachineOrderItemSeqId"/>
                                </entity-find>
                            </then>
                            <else>
                                <filter-map-list list="orderAssetReceiptList" to-list="currentAssetReceiptList">
                                    <field-map field-name="testMachineOrderItemSeqId"/>
                                </filter-map-list>
                            </else>
                        </if>

                        <!-- add up quantity in currentAssetIssuanceList, compare to testMachineOrderItem.quantity -->
                        <set field="currentQuantityTotal" from="0" type="BigDecimal"/>
                        <iterate list="currentAssetIssuanceList" entry="currentAssetIssuance">
                            <set field="currentQuantityTotal"
                                 from="currentQuantityTotal + currentAssetIssuance.quantity"/>
                        </iterate>
                        <iterate list="currentAssetReceiptList" entry="currentAssetReceipt">
                            <set field="currentQuantityTotal"
                                 from="currentQuantityTotal + currentAssetReceipt.quantityAccepted"/>
                        </iterate>
                        <if condition="currentQuantityTotal &lt; testMachineOrderItem.quantity">
                            <set field="isFulfilled" from="false"/>
                        </if>
                    </if>

                </then>
                <else>
                    <!-- TODO: for non-product items look for parent that is fulfilled? -->
                    <!-- NOTE 2021-02-12 this service is only used to check isFulfilled#OrderPart so far, so this alternate definition of fulfilled isn't needed -->
                </else>
            </if>
        </actions>
    </service>


    <service verb="complete" noun="TestMachineOrder">
        <implements service="beiyelin.testmachine.TestMachineOrderServices.change#TestMachineOrderStatusInterface"/>
        <in-parameters>
            <parameter name="completedDate" type="Timestamp" default="ec.user.nowTimestamp"/>
        </in-parameters>
        <actions>
            <service-call name="beiyelin.testmachine.TestMachineOrderServices.update#TestMachineOrderStatus"
                          out-map="context" in-map="context + [statusId:'TMOHSCompleted']"/>
        </actions>
    </service>

    <service verb="cancel" noun="TestMachineOrder">
        <implements service="beiyelin.testmachine.TestMachineOrderServices.change#TestMachineOrderStatusInterface"/>
        <!-- TODO add reject parameter to use TMOHSRejected status instead of TMOHSCancelled -->
        <actions>
            <!-- does partial cancel if already partially shipped, and then set what is left as completed; otherwise does a full cancel -->
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader"
                             value-field="testMachineOrderHeader" for-update="true"/>
            <if condition="testMachineOrderHeader == null">
                <return error="true" message="TestMachineOrder ${testMachineOrderId} not found"/>
            </if>
            <if condition="testMachineOrderHeader.statusId == 'TMOHSCompleted'">
                <return error="true"
                        message="Cannot cancel testMachineOrder ${testMachineOrderId}, already Completed"/>
            </if>
            <if condition="testMachineOrderHeader.statusId in ['TMOHSRejected', 'TMOHSCancelled']">
                <return message="TestMachineOrder ${testMachineOrderId} already Cancelled"/>
            </if>

            <!-- cancel item quantities not issued, update or remove ShipmentItemSource records, remove asset reservations if any -->
            <entity-find entity-name="mantle.product.issuance.AssetIssuance" list="fullAssetIssuanceList">
                <econdition field-name="testMachineOrderId"/>
            </entity-find>
            <entity-find entity-name="mantle.shipment.ShipmentItemSource" list="fullShipmentItemSourceList">
                <econdition field-name="testMachineOrderId"/>
            </entity-find>

            <set field="quantityIssued" from="0.0"/>
            <iterate list="fullAssetIssuanceList" entry="assetIssuance">
                <set field="quantityIssued" from="quantityIssued + assetIssuance.quantity"/>
            </iterate>
            <set field="hasIssuedQuantity" from="quantityIssued &gt; 0.0"/>

            <entity-find entity-name="beiyelin.testmachine.TestMachineOrderItem" list="testMachineOrderItemList">
                <econdition field-name="testMachineOrderId"/>
            </entity-find>
            <iterate list="testMachineOrderItemList" entry="testMachineOrderItem">
                <service-call name="beiyelin.testmachine.TestMachineOrderServices.cancel#TestMachineOrderItem"
                              out-map="itemOut" out-map-add-to-existing="false"
                              in-map="[testMachineOrderId:testMachineOrderId, testMachineOrderItemSeqId:testMachineOrderItem.testMachineOrderItemSeqId, testMachineOrderItem:testMachineOrderItem, checkCancelPart:false,
                            fullAssetIssuanceList:fullAssetIssuanceList, fullShipmentItemSourceList:fullShipmentItemSourceList]"/>
            </iterate>


            <!-- cancel or complete testMachineOrder header -->
            <service-call name="update#beiyelin.testmachine.TestMachineOrderHeader" out-map="context"
                          in-map="[testMachineOrderId:testMachineOrderId, statusId:targetStatusId]"/>
        </actions>
    </service>

    <service verb="cancel" noun="TestMachineOrderItem" no-tx-cache="true">
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <parameter name="testMachineOrderItemSeqId" required="true"/>
            <parameter name="cancelQuantity" type="BigDecimal">
                <description>Defaults to quantity not yet issued, if greater than quantity not issued will be reduced to
                    quantity not issued
                </description>
            </parameter>
            <parameter name="testMachineOrderItem" type="EntityValue"/>
            <parameter name="fullAssetIssuanceList" type="List">
                <parameter name="assetIssuance" type="EntityValue"/>
            </parameter>
            <parameter name="fullShipmentItemSourceList" type="List">
                <parameter name="shipmentItemSource" type="EntityValue"/>
            </parameter>
            <parameter name="checkCancelPart" type="Boolean" default="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="hasIssuedQuantity" type="Boolean"/>
            <parameter name="quantityCancelled" type="BigDecimal"/>
        </out-parameters>
        <actions>
            <if condition="testMachineOrderItem == null">
                <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderItem"
                                 value-field="testMachineOrderItem"/>
            </if>
            <if condition="testMachineOrderItem == null">
                <return error="true"
                        message="TestMachineOrder Item ${testMachineOrderId}:${testMachineOrderItemSeqId} not found"/>
            </if>

            <!-- only do this for product items -->
            <if condition="!testMachineOrderItem.productId">
                <return/>
            </if>

            <!-- check quantity issued -->
            <if condition="fullAssetIssuanceList">
                <then>
                    <filter-map-list list="fullAssetIssuanceList" to-list="itemAssetIssuanceList">
                        <field-map field-name="testMachineOrderItemSeqId"/>
                        <field-map field-name="productId" from="testMachineOrderItem.productId"/>
                    </filter-map-list>
                </then>
                <else>
                    <entity-find entity-name="mantle.product.issuance.AssetIssuance" list="itemAssetIssuanceList">
                        <econdition field-name="testMachineOrderId"/>
                        <econdition field-name="testMachineOrderItemSeqId"/>
                        <econdition field-name="productId" from="testMachineOrderItem.productId"/>
                    </entity-find>
                </else>
            </if>

            <set field="itemQuantityIssued" from="0.0"/>
            <iterate list="itemAssetIssuanceList" entry="itemAssetIssuance">
                <set field="itemQuantityIssued" from="itemQuantityIssued + itemAssetIssuance.quantity"/>
            </iterate>
            <set field="hasIssuedQuantity" from="itemQuantityIssued &gt; 0.0"/>

            <!-- determine quantity to cancel -->
            <set field="itemQuantity"
                 from="testMachineOrderItem.quantity != null ? testMachineOrderItem.quantity : 1.0"/>
            <set field="notIssuedQuantity" from="itemQuantity - itemQuantityIssued"/>
            <if condition="notIssuedQuantity &lt; 0.0">
                <log level="warn"
                     message="In cancel#TestMachineOrderItem itemQuantityIssued ${itemQuantityIssued} is greater than itemQuantity ${itemQuantity}, using 0.0 for notIssuedQuantity instead of ${notIssuedQuantity}"/>
                <set field="notIssuedQuantity" from="0.0"/>
            </if>
            <if condition="cancelQuantity">
                <then>
                    <if condition="cancelQuantity &gt; notIssuedQuantity">
                        <then>
                            <set field="quantityCancelled" from="notIssuedQuantity"/>
                            <message type="warning">Cannot cancel quantity ${cancelQuantity}, only ${notIssuedQuantity}
                                not yet shipped for TestMachineOrder Item
                                ${testMachineOrderId}:${testMachineOrderItemSeqId}
                            </message>
                        </then>
                        <else>
                            <set field="quantityCancelled" from="cancelQuantity"/>
                        </else>
                    </if>
                </then>
                <else>
                    <set field="quantityCancelled" from="notIssuedQuantity"/>
                </else>
            </if>

            <if condition="!quantityCancelled">
                <return/>
            </if>

            <!-- update the TestMachineOrderItem -->
            <service-call name="update#beiyelin.testmachine.TestMachineOrderItem" in-map="[testMachineOrderId:testMachineOrderId,
                        testMachineOrderItemSeqId:testMachineOrderItem.testMachineOrderItemSeqId,
                        quantityCancelled:(quantityCancelled + (testMachineOrderItem.quantityCancelled ?: 0)),
                        quantity:(itemQuantity - quantityCancelled)]"/>

            <!-- adjust child items (usually discount and tax) for new quantity -->
            <!-- NOTE this is simpler than other prorating because it is only done once, then the item is either completed if partially filled or cancelled otherwise -->
            <!-- NOTE skip discounts if isPromo=Y? those will be handled by testMachineOrder update triggers, if enabled; maybe best to calc here and disable promo calc (are disabled by default for orders Approved, etc) -->
            <if condition="itemQuantity == quantityCancelled">
                <then>
                    <set field="childCancelRatio" from="1.0"/>
                </then>
                <else>
                    <set field="childCancelRatio"
                         from="(quantityCancelled as BigDecimal).divide(itemQuantity as BigDecimal, 6, BigDecimal.ROUND_HALF_EVEN)"/>
                </else>
            </if>
            <set field="childOrderItemList"
                 from="testMachineOrderItem.'Child#beiyelin.testmachine.TestMachineOrderItem'"/>
            <order-map-list list="childOrderItemList">
                <order-by field-name="testMachineOrderItemSeqId"/>
            </order-map-list>
            <iterate list="childOrderItemList" entry="childOrderItem">
                <if condition="childOrderItem.quantity == 0.0 || childOrderItem.unitPrice == 0.0">
                    <continue/>
                </if>
                <if condition="childOrderItem.quantity == itemQuantity">
                    <then>
                        <!-- if child qty == parent qty no need to prorate, just adjust quantities to match -->
                        <service-call name="update#beiyelin.testmachine.TestMachineOrderItem" in-map="[testMachineOrderId:testMachineOrderId,
                        testMachineOrderItemSeqId:childOrderItem.testMachineOrderItemSeqId,
                        quantityCancelled:(quantityCancelled + (childOrderItem.quantityCancelled ?: 0)),
                        quantity:(itemQuantity - quantityCancelled)]"/>
                    </then>
                    <else>
                        <!-- quantity doesn't match, leave quantity alone and prorate unitPrice -->
                        <set field="newunitPrice"
                             from="childOrderItem.unitPrice - ((childCancelRatio as BigDecimal) * (childOrderItem.unitPrice as BigDecimal)).setScale(2, BigDecimal.ROUND_HALF_UP)"/>
                        <service-call name="update#beiyelin.testmachine.TestMachineOrderItem" in-map="[testMachineOrderId:testMachineOrderId,
                        testMachineOrderItemSeqId:childOrderItem.testMachineOrderItemSeqId, unitPrice:newunitPrice]"/>
                    </else>
                </if>
            </iterate>

            <!-- update or remove ShipmentItemSource records -->
            <if condition="fullShipmentItemSourceList">
                <then>
                    <filter-map-list list="fullShipmentItemSourceList" to-list="itemShipmentItemSourceList">
                        <field-map field-name="testMachineOrderItemSeqId"/>
                    </filter-map-list>
                </then>
                <else>
                    <entity-find entity-name="mantle.shipment.ShipmentItemSource" list="itemShipmentItemSourceList">
                        <econdition field-name="testMachineOrderId"/>
                        <econdition field-name="testMachineOrderItemSeqId"/>
                    </entity-find>
                </else>
            </if>

            <set field="shipmentItemQuantityReducedMap" from="[:]"/>
            <set field="shipQuantityRemaining" from="quantityCancelled"/>
            <iterate list="itemShipmentItemSourceList" entry="itemShipmentItemSource">
                <set field="shipQuantityToReduce" from="shipQuantityRemaining &gt; itemShipmentItemSource.quantityNotHandled ?
                        itemShipmentItemSource.quantityNotHandled : shipQuantityRemaining"/>
                <if condition="!shipQuantityToReduce">
                    <continue/>
                </if>
                <script>addToBigDecimalInMap(itemShipmentItemSource.shipmentId, shipQuantityToReduce, shipmentItemQuantityReducedMap)</script>
                <!-- reduce quantity by quantityNotHandled -->
                <service-call name="update#mantle.shipment.ShipmentItemSource"
                              in-map="[shipmentItemSourceId:itemShipmentItemSource.shipmentItemSourceId, quantityNotHandled:0,
                                quantity:(itemShipmentItemSource.quantity - shipQuantityToReduce)]"/>

                <set field="shipQuantityRemaining" from="shipQuantityRemaining - shipQuantityToReduce"/>
            </iterate>

            <iterate list="shipmentItemQuantityReducedMap" entry="shipmentItemQuantityReduced" key="shipmentId">
                <entity-find-one entity-name="mantle.shipment.ShipmentItem" value-field="shipmentItem">
                    <field-map field-name="shipmentId"/>
                    <field-map field-name="productId" from="testMachineOrderItem.productId"/>
                </entity-find-one>
                <if condition="shipmentItem != null">
                    <set field="newSiQuantity" from="shipmentItem.quantity &gt; shipmentItemQuantityReduced ?
                                shipmentItem.quantity - shipmentItemQuantityReduced : 0.0"/>
                    <service-call name="update#mantle.shipment.ShipmentItem"
                                  in-map="[shipmentId:shipmentId, productId:testMachineOrderItem.productId, quantity:newSiQuantity]"/>

                    <if condition="newSiQuantity == 0.0">
                        <!-- if no ShipmentItems have quantity greater than 0.0 cancel Shipment -->
                        <entity-find-count entity-name="mantle.shipment.ShipmentItem"
                                           count-field="nonZeroShipItemCount">
                            <econdition field-name="shipmentId"/>
                            <econdition field-name="quantity" operator="greater" from="0.0"/>
                        </entity-find-count>
                        <if condition="nonZeroShipItemCount == 0">
                            <!-- cancel#Shipment won't do what it normally does reducing quantities, but just in case other cleanups needed -->
                            <service-call name="mantle.shipment.ShipmentServices.cancel#Shipment"
                                          in-map="[shipmentId:shipmentId]"/>
                        </if>
                    </if>
                </if>
            </iterate>

            <if condition="quantityCancelled == notIssuedQuantity">
                <then>
                    <!-- if quantityCancelled == notIssuedQuantity remove all OrderItem Reservations -->
                    <service-call name="mantle.product.AssetServices.remove#TestMachineOrderItemReservations"
                                  in-map="[testMachineOrderId:testMachineOrderId, testMachineOrderItemSeqId:testMachineOrderItem.testMachineOrderItemSeqId]"/>

                </then>
                <else>
                    <!-- reduce OrderItem Reservations by quantityCancelled? no need to, AssetReservation ECA rule will pick it up -->
                </else>
            </if>
        </actions>
    </service>

    <!-- ============================================================== -->
    <!-- ========== Clone TestMachineOrder and Recurring TestMachineOrder Services ========== -->
    <!-- ============================================================== -->

    <service verb="clone" noun="TestMachineOrder">
        <description>Clone an order. Always copies the TestMachineOrderHeader and TestMachineOrderItem records.
        </description>
        <in-parameters>
            <parameter name="baseOrderId" required="true" default="testMachineOrderId"/>
            <parameter name="testMachineOrderId"/>
            <auto-parameters entity-name="beiyelin.testmachine.TestMachineOrderHeader" include="nonpk">
                <exclude field-name="parentOrderId"/>
            </auto-parameters>

            <parameter name="requiredByDate" type="Timestamp"/>
            <parameter name="statusId" default-value="OrderOpen"/>
            <parameter name="requestDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="orderRevision" type="Integer" default="1"/>
            <parameter name="clearDates" type="Boolean" default="true"/>
<!--            <parameter name="copyContactMech" type="Boolean" default="true"/>-->
            <parameter name="copyContent" type="Boolean" default="true"/>
            <parameter name="copyNote" type="Boolean" default="true"/>
            <parameter name="copyParty" type="Boolean" default="true"/>
<!--            <parameter name="copyTerm" type="Boolean" default="true"/>-->
        </in-parameters>
        <out-parameters>
            <parameter name="testMachineOrderId"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader"
                             value-field="testMachineOrderHeader">
                <field-map field-name="testMachineOrderId" from="baseOrderId"/>
            </entity-find-one>

            <!-- clear and sequence new testMachineOrderId -->
            <set field="testMachineOrderHeader.testMachineOrderId" from="null"/>
            <entity-sequenced-id-primary value-field="testMachineOrderHeader"/>

            <!-- set nonpk fields from context, if passed -->
            <entity-set value-field="testMachineOrderHeader" include="nonpk"/>

            <!-- set or clear fields related to testMachineOrder cloning and recurrence -->
            <set field="testMachineOrderHeader.parentOrderId" from="baseOrderId"/>

            <if condition="clearDates">
                <!-- set the fields even if null, don't do this for other fields -->
                <set field="testMachineOrderHeader.requestDate" from="requestDate"/>
                <set field="testMachineOrderHeader.placedDate" from="placedDate"/>
                <set field="testMachineOrderHeader.approvedDate" from="approvedDate"/>
                <set field="testMachineOrderHeader.completedDate" from="completedDate"/>
                <!-- don't set this on clones, used for recurring orders to track last date/time of clone/recurrence: <set field="testMachineOrderHeader.lastOrderedDate" from="lastOrderedDate"/> -->
            </if>

            <!-- create new OrderHeader -->
            <entity-create value-field="testMachineOrderHeader"/>
            <set field="testMachineOrderId" from="testMachineOrderHeader.testMachineOrderId"/>

            <entity-find entity-name="beiyelin.testmachine.TestMachineOrderItem" list="valueList">
                <econdition field-name="testMachineOrderId" from="baseOrderId"/>
                <order-by field-name="testMachineOrderItemSeqId"/>
            </entity-find>
            <iterate list="valueList" entry="value">
                <set field="value.testMachineOrderId" from="testMachineOrderId"/>
                <set field="value.testMachineOrderItemSeqId" from="null"/>
                <entity-sequenced-id-secondary value-field="value"/>
                <entity-create value-field="value"/>
            </iterate>

<!--            <if condition="copyContactMech">-->
<!--                <entity-find entity-name="beiyelin.testmachine.TestMachineOrderPartContactMech" list="valueList">-->
<!--                    <econdition field-name="testMachineOrderId" from="baseOrderId"/></entity-find>-->
<!--                <iterate list="valueList" entry="value"><set field="value.testMachineOrderId" from="testMachineOrderId"/><entity-create value-field="value"/></iterate>-->
<!--            </if>-->
            <if condition="copyContent">
                <entity-find entity-name="beiyelin.testmachine.TestMachineOrderContent" list="valueList">
                    <econdition field-name="testMachineOrderId" from="baseOrderId"/>
                </entity-find>
                <iterate list="valueList" entry="value">
                    <set field="value.testMachineOrderId" from="testMachineOrderId"/>
                    <set field="value.orderContentId" from="null"/>
                    <entity-sequenced-id-primary value-field="value"/>
                    <entity-create value-field="value"/>
                </iterate>
            </if>
            <if condition="copyNote">
                <entity-find entity-name="beiyelin.testmachine.TestMachineOrderNote" list="valueList">
                    <econdition field-name="testMachineOrderId" from="baseOrderId"/>
                </entity-find>
                <iterate list="valueList" entry="value">
                    <set field="value.testMachineOrderId" from="testMachineOrderId"/>
                    <entity-create value-field="value"/>
                </iterate>
            </if>
            <if condition="copyParty">
                <entity-find entity-name="beiyelin.testmachine.TestMachineOrderParty" list="valueList">
                    <econdition field-name="testMachineOrderId" from="baseOrderId"/></entity-find>
                <iterate list="valueList" entry="value"><set field="value.testMachineOrderId" from="testMachineOrderId"/><entity-create value-field="value"/></iterate>
            </if>
<!--            <if condition="copyTerm">
                <entity-find entity-name="beiyelin.testmachine.TestMachineOrderPartTerm" list="valueList">
                    <econdition field-name="testMachineOrderId" from="baseOrderId"/></entity-find>
                <iterate list="valueList" entry="value"><set field="value.testMachineOrderId" from="testMachineOrderId"/><entity-create value-field="value"/></iterate>
            </if>-->

            <message type="success">Created TestMachineOrder ${testMachineOrderId} as a clone of TestMachineOrder
                ${baseOrderId}
            </message>
        </actions>
    </service>

    <!-- ==================================================== -->
    <!-- ========== TestMachineOrder Change Response Services ========== -->
    <!-- ==================================================== -->

    <service verb="handle" noun="TestMachineOrderItemChange">
        <description>Called by EECA rule on TestMachineOrderItem create/update/delete</description>
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <parameter name="testMachineOrderItemSeqId"/>
            <parameter name="itemTypeEnumId"/>
            <parameter name="quantity" type="BigDecimal"/>
            <parameter name="unitPrice" type="BigDecimal"/>
            <parameter name="originalValue" type="Map"/>
            <parameter name="eecaOperation"/>
        </in-parameters>
        <actions>
            <if condition="eecaOperation == 'delete'">
                                <service-call name="beiyelin.testmachine.TestMachineOrderServices.update#OrderHeaderTotal" in-map="context"/>
                <!-- NOTE: OrderServices.handle#TestMachineOrderMajorChange is called by delete#OrderItem -->
                <return/>
            </if>

            <if condition="!originalValue || quantity != originalValue.quantity || unitPrice != originalValue.unitPrice ">
                <then>
                    <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader"
                                     value-field="testMachineOrderHeader" for-update="true"/>
                    <service-call name="beiyelin.testmachine.TestMachineOrderServices.update#OrderHeaderTotal"
                                  in-map="context"/>

                    <!--                     NOTE: no need to increment#OrderRevision, will be done when part updated -->
                </then>
                <else>
                    <!-- increment testMachineOrder revision if anything else changes on an item -->
                    <service-call name="beiyelin.testmachine.TestMachineOrderServices.increment#OrderRevision"
                                  in-map="context"/>
                </else>
            </if>
        </actions>
    </service>

<!--
    <service verb="handle" noun="TestMachineOrderMajorChange">
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <parameter name="testMachineOrderHeader" type="EntityValue"/>
        </in-parameters>
        <actions>
            &lt;!&ndash; use ec.context.sharedMap for a reentrant semaphore (sort of, not thread safe but all needed to prevent incorrect/infinite recursion) &ndash;&gt;
            <set field="sharedFlagKey" from="'TestMachineOrderMajorChange' + testMachineOrderId "/>
            <if condition="ec.context.getSharedMap().get(sharedFlagKey)">
                <return/>
            </if>

            <if condition="testMachineOrderHeader == null">
                <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader"
                                 value-field="testMachineOrderHeader" for-update="true"/>
            </if>
            <if condition="testMachineOrderHeader.productStoreId">
                <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderPart" value-field="orderPart"
                                 for-update="true"/>
                <set field="noRecalcStatuses"
                     from="['TMOHSApproved', 'OrderSent', 'OrderCompleted', 'TMOHSRejected', 'TMOHSCancelled']"/>
                <if condition="testMachineOrderHeader.statusId in noRecalcStatuses">
                    <return type="warning"
                            message="Not updating promotions, shipping, or tax for testMachineOrder ${testMachineOrderId} in status ${testMachineOrderHeader.status?.description}"/>
                </if>
                <if condition="orderPart.statusId in noRecalcStatuses">
                    <return type="warning"
                            message="Not updating promotions, shipping, or tax for testMachineOrder part ${testMachineOrderId}:${orderPartSeqId} in status ${orderPart.status?.description}"/>
                </if>

                &lt;!&ndash; make sure no billing done, don't auto update if so &ndash;&gt;
                <entity-find-count entity-name="beiyelin.testmachine.TestMachineOrderItemBillingDetail"
                                   count-field="partBillingCount">
                    <econdition field-name="testMachineOrderId"/>
                    <econdition field-name="orderPartSeqId"/>
                </entity-find-count>
                <if condition="partBillingCount">
                    <return type="warning"
                            message="Not updating promotions, shipping, or tax for testMachineOrder part ${testMachineOrderId}:${orderPartSeqId} with ${partBillingCount} OrderItemBilling records"/>
                </if>

                &lt;!&ndash; set flag in context root to avoid recursive triggers &ndash;&gt;
                <script>ec.context.getSharedMap().put(sharedFlagKey, true)</script>

                &lt;!&ndash; Apply Promotions &ndash;&gt;
                <if condition="!'Y'.equals(orderPart.disablePromotions)">
                    <entity-find entity-name="beiyelin.testmachine.TestMachineOrderItem" list="promoItemList">
                        <econdition field-name="testMachineOrderId"/>
                        <econdition field-name="orderPartSeqId"/>
                        <econdition field-name="isPromo" value="Y"/>
                    </entity-find>
                    <iterate list="promoItemList" entry="promoItem">
                        <service-call name="beiyelin.testmachine.TestMachineOrderServices.delete#OrderItem"
                                      in-map="[testMachineOrderId:promoItem.testMachineOrderId, testMachineOrderItemSeqId:promoItem.testMachineOrderItemSeqId]"/>
                    </iterate>
                    <service-call name="mantle.product.PromotionServices.apply#OrderPromotions"
                                  in-map="[testMachineOrderId:testMachineOrderId, orderPartSeqId:orderPartSeqId, testMachineOrderHeader:testMachineOrderHeader]"/>
                </if>

                &lt;!&ndash; Check for promotions with free ground shipping (if shipmentMethodEnumId == ShMthGround) &ndash;&gt;
                <set field="doShipCalc" from="true"/>
                <if condition="'ShMthGround'.equals(orderPart.shipmentMethodEnumId)">
                    &lt;!&ndash; get promotions applied &ndash;&gt;
                    <entity-find entity-name="beiyelin.testmachine.TestMachineOrderItem" list="shipPromoItemList"
                                 distinct="true">
                        <econdition field-name="testMachineOrderId"/>
                        <econdition field-name="orderPartSeqId"/>
                        <econdition field-name="isPromo" value="Y"/>
                        <econdition field-name="storePromotionId" operator="is-not-null"/>
                        <select-field field-name="storePromotionId"/>
                    </entity-find>
                    &lt;!&ndash; this may look inefficient, but the best way to get arbitrary set of cached ProductStorePromotion values &ndash;&gt;
                    <iterate list="shipPromoItemList" entry="shipPromoItem">
                        <entity-find-one entity-name="mantle.product.store.ProductStorePromotion"
                                         value-field="storePromotion" cache="true">
                            <field-map field-name="storePromotionId" from="shipPromoItem.storePromotionId"/>
                        </entity-find-one>
                        <if condition="'Y'.equals(storePromotion?.freeGroundShipping)">
                            <set field="doShipCalc" from="false"/>
                            <break/>
                        </if>
                    </iterate>
                </if>

                &lt;!&ndash; Calculate Shipping, after promotions so that testMachineOrder total/etc is adjusted for them &ndash;&gt;
                <if condition="!'Y'.equals(orderPart.disableShippingCalc)">
                    <entity-find entity-name="beiyelin.testmachine.TestMachineOrderItem" list="shippingItemList">
                        <econdition field-name="testMachineOrderId"/>
                        <econdition field-name="orderPartSeqId"/>
                        <econdition field-name="itemTypeEnumId" value="ItemShipping"/>
                    </entity-find>
                    <iterate list="shippingItemList" entry="shippingItem">
                        <service-call name="beiyelin.testmachine.TestMachineOrderServices.delete#OrderItem"
                                      in-map="[testMachineOrderId:shippingItem.testMachineOrderId, testMachineOrderItemSeqId:shippingItem.testMachineOrderItemSeqId]"/>
                    </iterate>
                    <if condition="doShipCalc">
                        <service-call name="mantle.shipment.CarrierServices.calculate#OrderPartShipping"
                                      in-map="[testMachineOrderId:testMachineOrderId, orderPartSeqId:orderPartSeqId, createOrderItem:true]"/>
                    </if>
                </if>

                &lt;!&ndash; Calculate Tax, after Shipping as it might be taxed &ndash;&gt;
                <if condition="!'Y'.equals(orderPart.disableTaxCalc)">
                    <entity-find entity-name="beiyelin.testmachine.TestMachineOrderItem" list="taxItemList">
                        <econdition field-name="testMachineOrderId"/>
                        <econdition field-name="orderPartSeqId"/>
                        <econdition field-name="itemTypeEnumId" operator="in" value="ItemSalesTax,ItemVatTax"/>
                    </entity-find>
                    <iterate list="taxItemList" entry="taxItem">
                        <service-call name="beiyelin.testmachine.TestMachineOrderServices.delete#OrderItem"
                                      in-map="[testMachineOrderId:taxItem.testMachineOrderId, testMachineOrderItemSeqId:taxItem.testMachineOrderItemSeqId]"/>
                    </iterate>
                    <service-call name="mantle.other.TaxServices.calculate#OrderSalesTax"
                                  in-map="[testMachineOrderId:testMachineOrderId, orderPartSeqId:orderPartSeqId]"/>
                </if>

                <script>ec.context.getSharedMap().remove(sharedFlagKey)</script>

                <service-call name="beiyelin.testmachine.TestMachineOrderServices.increment#OrderRevision"
                              in-map="context"/>
            </if>
        </actions>
    </service>
-->

    <service verb="update" noun="OrderHeaderTotal">
        <description>Update OrderHeader.grandTotal based on OrderItem.amount values</description>
        <in-parameters>
            <parameter name="testMachineOrderId"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader"
                             value-field="testMachineOrderHeader" for-update="true"/>
            <set field="totalSum" from="0.0" type="BigDecimal"/>
            <entity-find entity-name="beiyelin.testmachine.TestMachineOrderItem" list="testMachineOrderItemList">
                <econdition field-name="testMachineOrderId"/>
            </entity-find>
            <iterate list="testMachineOrderItemList" entry="testMachineOrderItem">
                <set field="totalSum" from="totalSum + (testMachineOrderItem.amount ?: 0)"/>
            </iterate>
            <set field="testMachineOrderHeader.grandTotal" from="totalSum"/>
            <entity-update value-field="testMachineOrderHeader"/>
        </actions>
    </service>

    <service verb="increment" noun="OrderRevision">
        <in-parameters>
            <parameter name="testMachineOrderId"/>
        </in-parameters>
        <actions>
            <if condition="!testMachineOrderId">
                <return/>
            </if>
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader"
                             value-field="testMachineOrderHeader" for-update="true">
                <field-map field-name="testMachineOrderId"/>
            </entity-find-one>
            <!-- TODO: not using <select-field field-name="testMachineOrderId,orderRevision"/> because of issue in EntityValue where a bunch of stuff gets set to null -->
            <if condition="testMachineOrderHeader != null">
                <set field="testMachineOrderHeader.orderRevision"
                     from="(testMachineOrderHeader.orderRevision ?: 1) + 1"/>
                <entity-update value-field="testMachineOrderHeader"/>
            </if>
        </actions>
    </service>

    <service verb="reserve" noun="AssetsForTestMachineOrder" no-tx-cache="true">
        <description>手工出发，在Placed之前完成，在Placed的时候也可以指定，是否自动完成</description>
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <parameter name="autoReserve" type="Boolean" default="false"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader" value-field="testMachineOrderHeader"/>


            <if condition="autoReserve">
                <entity-find-one entity-name="mantle.facility.facility" value-field="ownerPartyId" cache="true">
                    <field-map field-name="facilityId" from="testMachineOrderHeader.vendorFacilityId"/>
                </entity-find-one>
                
                <entity-find-one entity-name="mantle.party.Organization" value-field="reservationOrderEnumId">
                    <field-map field-name="partyId" from="ownerPartyId"/>
                </entity-find-one>
                <if condition="reservationOrderEnumId == null"><set field="reservationOrderEnumId" from="'AsResOrdNoRes'"/></if>
                <if condition="reservationOrderEnumId == 'AsResOrdNoRes'"><return/></if>

            </if>

            <set field="resStatusList" from="['TMOHSApproved']"/>
            <if condition="!(testMachineOrderHeader.statusId in resStatusList) || !(orderPart.statusId in resStatusList)"><continue/></if>

            <entity-find entity-name="beiyelin.testmachine.TestMachineOrderItem" list="testMachineOrderItemList">
                <econdition field-name="testMachineOrderId"/>
                <econdition field-name="productId" operator="is-not-null"/>
                <!-- order by productId to avoid deadlocks -->
                <order-by field-name="productId"/>
            </entity-find>
            <iterate list="testMachineOrderItemList" entry="testMachineOrderItem">
                <service-call name="beiyelin.testmachine.TestMachineServices.reserve#AssetForTestMachineOrderItem"
                              in-map="[testMachineOrderId:testMachineOrderId, testMachineOrderItemSeqId:testMachineOrderItem.testMachineOrderItemSeqId, productStore:productStore, forceReserve:forceReserve]"/>
            </iterate>

        </actions>
    </service>
    <service verb="checkReserve" noun="AssetForTestMachineOrderItem">
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <parameter name="testMachineOrderItemSeqId" required="true"/>
            <parameter name="resetReservations" type="Boolean" default="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderItem" value-field="testMachineOrderItem"/>
            <if condition="testMachineOrderItem == null"><return error="true" message="TestMachineOrder Item ${testMachineOrderId}:${testMachineOrderItemSeqId} not found"/></if>
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader" value-field="testMachineOrderHeader"/>
            <if condition="testMachineOrderHeader == null"><return error="true" message="TestMachineOrder ${testMachineOrderId} not found"/></if>

            <if condition="testMachineOrderHeader.statusId != 'TMOHSApproved'"><return/></if>


<!--            &lt;!&ndash; regardless of settings only skip reservation update if there are no reservations (if reservations update for quantity changes, etc) &ndash;&gt;-->
<!--            <entity-find entity-name="mantle.product.issuance.AssetReservation" list="existingResList">-->
<!--                <econdition field-name="testMachineOrderId"/><econdition field-name="testMachineOrderItemSeqId"/></entity-find>-->
<!--            <if condition="!existingResList">-->
<!--                &lt;!&ndash; only do this automatically if order placed or later but not completed/cancelled/etc &ndash;&gt;-->
<!--                &lt;!&ndash; check OrderPart.reservationAutoEnumId vs current status &ndash;&gt;-->
<!--                <set field="reservationAutoEnumId" from="orderPart.reservationAutoEnumId ?: productStore?.reservationAutoEnumId ?: 'AsResAutoPlaced'"/>-->
<!--                <if condition="reservationAutoEnumId == 'AsResAutoNone'"><return/></if>-->
<!--                <if condition="reservationAutoEnumId == 'AsResAutoApproved'"><then>-->
<!--                    <set field="resStatusList" from="['TMOHSApproved', 'OrderSent']"/>-->
<!--                </then><else>-->
<!--                    <set field="resStatusList" from="['OrderPlaced', 'OrderProcessing', 'TMOHSApproved', 'OrderSent', 'OrderHold']"/>-->
<!--                </else></if>-->
<!--                <if condition="!(testMachineOrderHeader.statusId in resStatusList) || !(orderPart.statusId in resStatusList)"><return/></if>-->
<!--            </if>-->

            <!-- reserve assets, or update reservations as needed -->
            <service-call name="beiyelin.testmachine.TestMachineOrderServices.reserve#AssetForTestMachineOrderItem" in-map="context"/>
        </actions>
    </service>
    <service verb="reserve" noun="AssetForTestMachineOrderItem" no-tx-cache="true">
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <parameter name="testMachineOrderItemSeqId" required="true"/>
            <parameter name="assetId"><description>Optional assetId, reserves against this first if specified.</description></parameter>
            <parameter name="assetIdList" type="List">
                <description>Optional List of assetId values, reserves against these first (in order) if specified.</description>
                <parameter name="assetId"/>
            </parameter>
            <parameter name="resetReservations" type="Boolean" default="false"><description>If true remove existing reservations before reserving.</description></parameter>
            <parameter name="skipAssetIds" type="Collection">
                <description>Don't reserve to this Asset, for displace/etc</description>
                <parameter name="assetId"/>
            </parameter>
            <parameter name="forceReserve" type="Boolean" default="false">
                <description>Ignore validations on ProductStore.reservationAutoEnumId, presence of productStoreId or vendorPartyId in OrgInternal role</description></parameter>

            <parameter name="componentProductId"/>
            <parameter name="componentQuantity" type="BigDecimal"/>
        </in-parameters>
        <actions>
            <set field="nowTimestamp" from="ec.user.nowTimestamp"/>

            <!-- do a FOR UPDATE query on OrderItem as a semaphore (will also need on Asset records, done below) -->
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderItem" value-field="testMachineOrderItem" for-update="true"/>
            <if condition="testMachineOrderItem == null"><return error="true" message="TestMachineOrder Item ${testMachineOrderId}:${testMachineOrderItemSeqId} not found"/></if>

            <if condition="componentProductId"><log level="warn" message="Component Product ${componentProductId} reserve ${componentQuantity} for TestMachineOrderItem ${testMachineOrderId}:${testMachineOrderItemSeqId} product ${testMachineOrderItem.productId}"/></if>

            <!-- first check the OrderItem, make sure we have a productId otherwise don't reserve -->
            <set field="productId" from="componentProductId ?: testMachineOrderItem.productId"/>
            <if condition="!productId"><return/></if>

            <!-- see if Product is a physical item -->
            <entity-find-one entity-name="mantle.product.Product" value-field="product" cache="true"/>
            <if condition="!(product.productTypeEnumId in ['PtAsset', 'PtDigitalAsset', 'PtAssetUse', 'PtPickAssembly'])"><return/></if>

            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader" value-field="testMachineOrderHeader"/>

            <!-- check testMachineOrderHeader  status, return immediately if not Approved -->
            <set field="resStatusList" from="['TMOHSApproved']"/>
            <if condition="!(testMachineOrderHeader.statusId in resStatusList) ">
                <return message="Not reserving, testMachineOrder in TMOHSApproved status that allows reservation"/></if>

<!--            如果是供应商直接发货，这无需占用库存-->
            <if condition="testMachineOrderHeader.facility == null">
                <return message="供应商直接发货，这无需占用库存"/>
            </if>

            <!-- before finding remaining quantity and getting existing reservations, resetReservations if specified -->
            <if condition="resetReservations">
                <service-call name="beiyelin.testmachine.TestMachineServices.remove#TestMachineOrderItemReservations" in-map="context"/></if>

            <!-- start with full item quantity -->
            <set field="quantityRemaining" from="componentQuantity != null ? componentQuantity : testMachineOrderItem.quantity"/>

            <!-- if componentProductId skip the AssetIssuance check, should be handled in calling instance for Pick Assembly type Product -->
            <if condition="!componentProductId">
                <!-- reduce quantity for already packed/issued -->
                <entity-find entity-name="mantle.product.issuance.AssetIssuance" list="assetIssuanceList">
                    <econdition field-name="testMachineOrderId"/><econdition field-name="testMachineOrderItemSeqId"/>
                </entity-find>
                <iterate list="assetIssuanceList" entry="assetIssuance">
                    <set field="quantityRemaining" from="quantityRemaining - assetIssuance.quantity"/>
                </iterate>
            </if>

            <!-- if there are any existing reservations, deduct their quantity -->
            <!-- NOTE this was for-update=true but should not be needed, we already locked the TestMachineOrderItem -->
            <entity-find entity-name="mantle.product.issuance.AssetReservation" list="existingResList">
                <econdition field-name="testMachineOrderId"/><econdition field-name="testMachineOrderItemSeqId"/>
                <!-- if PickAssembly Product or PA component must filter by productId -->
                <econdition field-name="productId" from="product.productId" ignore="!(componentProductId || product.productTypeEnumId == 'PtPickAssembly')"/>
                <!-- get most recent first for reducing reservation quantities -->
                <order-by field-name="-reservedDate"/>
            </entity-find>
            <iterate list="existingResList" entry="existingRes">
                <set field="quantityRemaining" from="quantityRemaining - existingRes.quantity"/>
            </iterate>

            <!-- if nothing to reserve or un-reserve return now -->
            <if condition="quantityRemaining &lt;= 0"><return/></if>

            <!-- handle too much reserved -->
            <if condition="quantityRemaining &lt; 0">
                <set field="quantityToDeduct" from="-quantityRemaining"/>
                <iterate list="existingResList" entry="existingRes">
                    <service-call name="mantle.product.AssetServices.reduce#AssetReservation" out-map="reduceArOut" out-map-add-to-existing="false"
                                  in-map="[assetReservationId:existingRes.assetReservationId, quantityToDeduct:quantityToDeduct, reserveIncreasedAsset:true]"/>
                    <set field="quantityToDeduct" from="quantityToDeduct - reduceArOut.quantityDeducted"/>
                    <if condition="quantityToDeduct == 0"><break/></if>
                </iterate>

                <if condition="quantityToDeduct != 0">
                    <return error="true" message="Unable to remove reservations for ${quantityToDeduct} out of ${-quantityRemaining} attempted, not enough quantity reserved and not issued"/>
                    <else><return/></else>
                </if>
            </if>
            <if condition="quantityRemaining &lt; 0">
                <log level="error" message="Quantity to reserve ${quantityRemaining} is less than zero; order item ${testMachineOrderId}:${testMachineOrderItemSeqId}, quantity ${testMachineOrderItem.quantity}; existingResList: ${existingResList}"/>
                <return error="true" message="Quantity to reserve ${quantityRemaining} is less than zero"/>
            </if>

            <!-- if organization setup for no reservation return now -->
            <set field="inventoryFacilityId" from="testMachineOrderHeader?.vendorFacilityId"/>
            <entity-find-one entity-name="mantle.facility.Facility" value-field="inventoryFacility" cache="true">
                <field-map field-name="facilityId" from="inventoryFacilityId"/></entity-find-one>

            <entity-find-one entity-name="mantle.party.organization" value-field="organization">
                <field-map field-name="partyId" from="inventoryFacility.ownerPartyId"/>
            </entity-find-one>

            <if condition="organization?.reservationOrderEnumId == 'AsResOrdNoRes'"><return/></if>
            <!-- otherwise set assetOrderBy field based on reservationOrderEnumId -->
            <set field="reservationOrderEnumId" from="organization?.reservationOrderEnumId ?: 'AsResOrdFifoRec'"/>
            <entity-find-one entity-name="moqui.basic.Enumeration" value-field="resOrderEnum">
                <field-map field-name="enumId" from="reservationOrderEnumId"/></entity-find-one>
            <set field="assetOrderBy" from="resOrderEnum?.enumCode ?: 'receivedDate'"/><!-- default: FIFO by received date -->

            <set field="assetAllowOtherOwner" from="inventoryFacility?.assetAllowOtherOwner"/>

            <!-- determine organizationPartyId -->
            <set field="organizationPartyId" from="testMachineOrderHeader?.vendorPartyId "/>
            <!-- if organizationPartyId is not an internal org ,  don't do inventory res (return) -->
            <entity-find-one entity-name="mantle.party.PartyRole" value-field="orgPartyRole" cache="true">
                <field-map field-name="partyId" from="organizationPartyId"/>
                <field-map field-name="roleTypeId" value="OrgInternal"/>
            </entity-find-one>
            <if condition="orgPartyRole == null">
                <if condition="forceReserve"><then>
                    <log message="Reserving inventory for testMachineOrder ${testMachineOrderId} item ${testMachineOrderItemSeqId} with vendor is not OrgInternal (forceReserve is true)"/>
                </then><else>
                    <return/>
                </else></if>
            </if>

            <!-- get ownerPartyId values to include -->
            <set field="ownerPartyIdSet" from="new HashSet()"/>
            <script>if (organizationPartyId) ownerPartyIdSet.add(organizationPartyId)</script>
            <if condition="organizationPartyId &amp;&amp; assetAllowOtherOwner != 'Y'">
                <!-- look for parent org(s) if any, include assets from parent org too -->
                <entity-find entity-name="mantle.party.PartyRelationship" list="parentRelList" cache="true">
                    <date-filter/>
                    <econdition field-name="relationshipTypeEnumId" value="PrtOrgRollup"/>
                    <econdition field-name="fromPartyId" from="organizationPartyId"/>
                    <econdition field-name="toPartyId" operator="is-not-null"/>
                </entity-find>
                <script>if (parentRelList) ownerPartyIdSet.addAll(parentRelList*.toPartyId)</script>
            </if>

            <!-- get assetPoolId values this order qualifies for (by store, vendor, customer) -->
            <service-call name="mantle.product.AssetServices.get#AssetPools" out-map="poolsOut"
                          in-map="[vendorPartyId:testMachineOrderHeader?.vendorPartyId,
                        customerPartyId:testMachineOrderHeader?.customerPartyId]"/>
            <set field="assetPoolIdSet" from="poolsOut.assetPoolIdSet"/>

            <!-- check and lock individual Asset records -->
            <set field="lockedAssetList" from="[]"/>
            <set field="checkQuantityRemaining" from="quantityRemaining"/>

            <!-- check/lock explicit assetIds -->
            <set field="explicitAssetIdList" from="[]"/>
            <if condition="assetId"><script>explicitAssetIdList.add(assetId)</script></if>
            <if condition="assetIdList"><script>explicitAssetIdList.addAll(assetIdList)</script></if>
            <if condition="explicitAssetIdList">
                <entity-find entity-name="mantle.product.asset.Asset" list="explicitAssetList">
                    <econdition field-name="assetId" operator="in" from="explicitAssetIdList"/>
                    <econdition field-name="productId"/>
                    <econdition field-name="quantityOnHandTotal" operator="greater" from="0.0"/>
                </entity-find>
                <set field="sortedExplicitAssetList" from="[]"/>
                <iterate list="explicitAssetIdList" entry="explicitAssetId">
                    <set field="explicitAsset" from="explicitAssetList.find({ it.assetId == explicitAssetId })"/>
                    <script>if (explicitAsset != null) sortedExplicitAssetList.add(explicitAsset)</script>
                </iterate>
                <!-- <log level="warn" message="explicitAssetIdList ${explicitAssetIdList}"/><log level="warn" message="sortedExplicitAssetList ${sortedExplicitAssetList}"/> -->
                <iterate list="sortedExplicitAssetList" entry="checkAsset">
                    <if condition="checkQuantityRemaining &lt;= 0.0"><break/></if>

                    <!-- if checkAsset.assetPoolId make sure order qualifies for pool -->
                    <if condition="checkAsset.assetPoolId &amp;&amp; !assetPoolIdSet.contains(checkAsset.assetPoolId)">
                        <message type="danger">Not reserving specified asset ${checkAsset.assetId} in pool ${checkAsset.assetPoolId} which is not available to this order</message>
                        <continue/>
                    </if>

                    <!-- here we do the lock query, check the ATP using the locked value -->
                    <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true">
                        <field-map field-name="assetId" from="checkAsset.assetId"/></entity-find-one>
                    <set field="quantityToReserve" from="asset.quantityOnHandTotal &gt; checkQuantityRemaining ? checkQuantityRemaining : asset.quantityOnHandTotal"/>
                    <if condition="quantityToReserve &gt; asset.availableToPromiseTotal">
                        <!-- displace existing reservations for explicit assetIds -->
                        <service-call name="beiyelin.product.AssetServices.displace#AssetReservations"
                                      in-map="[assetId:asset.assetId, testMachineOrderId:testMachineOrderId, testMachineOrderItemSeqId:testMachineOrderItemSeqId, quantity:quantityToReserve]"/>
                        <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true">
                            <field-map field-name="assetId" from="asset.assetId"/></entity-find-one>
                    </if>

                    <if condition="quantityToReserve &gt; 0.0">
                        <set field="checkQuantityRemaining" from="checkQuantityRemaining - quantityToReserve"/>
                        <script>lockedAssetList.add(asset)</script>
                    </if>
                </iterate>
            </if>
            <if condition="checkQuantityRemaining &gt; 0.0">
                <set field="baseAssetCond" from="[productId:productId, statusId:'AstAvailable']"/>
                <if condition="inventoryFacilityId"><set field="baseAssetCond.facilityId" from="inventoryFacilityId"/></if>
                <!-- TODO 20180503 remove this at some point, added to monitor corner case issue -->
                <if condition="!baseAssetCond.facilityId"><log level="warn" message="Reserving inventory for testMachineOrder ${testMachineOrderId} item ${testMachineOrderItemSeqId} with no vendorFacilityId"/></if>

                <!-- see if we need to try for single lot and newer inventory, done via lotsToUse list -->
                <set field="lotsToUse" from="null"/>
                <set field="singleLot" from="false"/>
                <set field="newerInventory" from="false"/>
                <if condition="testMachineOrderHeader.customerPartyId">
                    <set field="singleLot" from="'BlY'.equals(ec.service.sync().name('mantle.party.PartyServices.get#PartySettingValue')
                        .parameter('partySettingTypeId', 'CustomerSingleLot').parameter('partyId', orderPart.customerPartyId).call()?.get('settingValue'))"/>
                    <set field="newerInventory" from="'BlY'.equals(ec.service.sync().name('mantle.party.PartyServices.get#PartySettingValue')
                        .parameter('partySettingTypeId', 'CustomerNewerInventory').parameter('partyId', orderPart.customerPartyId).call()?.get('settingValue'))"/>
                </if>

                <if condition="singleLot || newerInventory">
                    <set field="newerThanExpireDate" from="null"/>
                    <if condition="newerInventory">
                        <!-- get most recent asset issued and lot expire date for it -->
                        <entity-find entity-name="mantle.product.issuance.AssetIssuanceLotSummary" list="issuanceLotList" limit="1">
                            <econdition field-name="toPartyId" from="orderPart.customerPartyId"/>
                            <econdition field-name="productId"/>
                            <select-field field-name="expirationDate,expectedEndOfLife"/>
                            <order-by field-name="-issuedDate"/>
                        </entity-find>
                        <if condition="issuanceLotList">
                            <set field="newerThanExpireDate" from="issuanceLotList[0].expirationDate ?: issuanceLotList[0].expectedEndOfLife"/></if>
                    </if>
                    <!-- do pre-query to find sufficient lots, or if no sufficient largest lots by order to minimize lots -->
                    <entity-find entity-name="mantle.product.asset.AssetLotSummary" list="lotSummaryList">
                        <econdition-object field="baseAssetCond"/>
                        <econdition field-name="ownerPartyId" operator="in" from="ownerPartyIdSet" ignore="assetAllowOtherOwner == 'Y' || !ownerPartyIdSet"/>
                        <econdition field-name="assetPoolId" operator="in" from="assetPoolIdSet" ignore="!assetPoolIdSet" or-null="true"/>
                        <econdition field-name="assetPoolId" operator="is-null" ignore="assetPoolIdSet"/>
                        <econdition field-name="expirationDate" operator="greater-equals" from="newerThanExpireDate" ignore-if-empty="true"/>
                        <select-field field-name="lotId,availableToPromiseTotal,manufacturedDate,expirationDate"/>
                        <!-- order to get fewest but sufficient available in a lot -->
                        <order-by field-name="availableToPromiseTotal"/>
                    </entity-find>
                    <set field="availableFoundByLot" from="0.0"/>
                    <iterate list="lotSummaryList" entry="lotSummary">
                        <set field="availableFoundByLot" from="availableFoundByLot + lotSummary.availableToPromiseTotal"/></iterate>
                    <!-- if no or insufficient records found and newerThanExpireDate, search again without -->
                    <if condition="availableFoundByLot &lt; checkQuantityRemaining &amp;&amp; newerThanExpireDate != null">
                        <!-- in this case we could get most recent inventory (-expirationDate) since we failed the newer than
                            constraint, but that would prioritize age over single lot so only do if !singleLot -->
                        <!-- when finding minimal lot or newest results are used in reverse order, so use expirationDate and not -expirationDate -->
                        <set field="lotRetryOrderBy" from="singleLot ? 'availableToPromiseTotal' : 'expirationDate'"/>
                        <entity-find entity-name="mantle.product.asset.AssetLotSummary" list="lotSummaryList">
                            <econdition-object field="baseAssetCond"/>
                            <econdition field-name="ownerPartyId" operator="in" from="ownerPartyIdSet" ignore="assetAllowOtherOwner == 'Y' || !ownerPartyIdSet"/>
                            <econdition field-name="assetPoolId" operator="in" from="assetPoolIdSet" ignore="!assetPoolIdSet" or-null="true"/>
                            <econdition field-name="assetPoolId" operator="is-null" ignore="assetPoolIdSet"/>
                            <select-field field-name="lotId,availableToPromiseTotal,manufacturedDate,expirationDate"/>
                            <order-by field-name="${lotRetryOrderBy}"/>
                        </entity-find>
                    </if>
                    <!-- if we found any lots look for singleLotId if singleLot, else use best candidate lots based on queries above -->
                    <if condition="lotSummaryList">
                        <set field="singleLotId" from="null"/>
                        <if condition="singleLot">
                            <!-- find first in list (smallest) lot with sufficient inventory and use it -->
                            <iterate list="lotSummaryList" entry="lotSummary">
                                <if condition="lotSummary.availableToPromiseTotal &gt;= checkQuantityRemaining">
                                    <set field="singleLotId" from="lotSummary.lotId"/><break/></if>
                            </iterate>
                        </if>
                        <if condition="singleLotId"><then>
                            <!-- <log level="warn" message="Found single lot ${singleLotId}"/> -->
                            <set field="lotsToUse" from="[singleLotId]"/>
                        </then><else><script><![CDATA[
                            // no single lot found? go end to beginning and use as many lots as needed
                            lotsToUse = []
                            BigDecimal lotQuantityRemaining = checkQuantityRemaining
                            for (int i = lotSummaryList.size() - 1; i >= 0; i--) {
                                def curLotSummary = lotSummaryList.get(i)
                                lotQuantityRemaining -= curLotSummary.availableToPromiseTotal
                                lotsToUse.add(curLotSummary.lotId)
                                if (lotQuantityRemaining <= 0.0) break
                            }
                            ]]></script></else></if>
                        <log level="warn" message="TestMachineOrder ${testMachineOrderId} Lots to use: ${lotsToUse}"/>
                    </if>
                </if>

                <!-- ========== main available query ========== -->
                <!-- reserve against pick locations first, then against other types or no location -->
                <if condition="checkQuantityRemaining &gt; 0.0">
                    <entity-find entity-name="mantle.product.asset.AssetLocationDetail" list="checkAssetList">
                        <!-- don't lock here, we'll lock records we need individually to avoid contention -->
                        <econdition-object field="baseAssetCond"/>
                        <econdition field-name="ownerPartyId" operator="in" from="ownerPartyIdSet" ignore="assetAllowOtherOwner == 'Y' || !ownerPartyIdSet"/>
                        <econdition field-name="assetPoolId" operator="in" from="assetPoolIdSet" ignore="!assetPoolIdSet" or-null="true"/>
                        <econdition field-name="assetPoolId" operator="is-null" ignore="assetPoolIdSet"/>
                        <!-- only look for Assets with available quantity, to reduce lock contention we'll create new records for negative ATP -->
                        <econdition field-name="availableToPromiseTotal" operator="greater" from="0.0"/>
                        <econdition field-name="assetId" operator="not-in" from="explicitAssetIdList" ignore-if-empty="true"/>
                        <econdition field-name="assetId" operator="not-in" from="skipAssetIds" ignore-if-empty="true"/>
                        <econdition field-name="lotId" operator="in" from="lotsToUse" ignore-if-empty="true"/>
                        <econdition field-name="statusId" value="AstAvailable"/>
                        <econdition field-name="locationTypeEnumId" value="FltPick"/>
                        <select-field field-name="${assetOrderBy},assetId"/>
                        <order-by field-name="${assetOrderBy},assetId"/>
                    </entity-find>
                    <!-- <log level="warn" message="checkAssetList find ${checkAssetList_xafind}\nSQL ${checkAssetList_xafind.getQueryTextList()}"/> -->
                    <iterate list="checkAssetList" entry="checkAsset">
                        <if condition="checkQuantityRemaining &lt;= 0.0"><break/></if>
                        <!-- here we do the lock query, check the ATP using the locked value -->
                        <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true">
                            <field-map field-name="assetId" from="checkAsset.assetId"/></entity-find-one>

                        <!-- TODO 20180503 remove this at some point, added to monitor corner case issue -->
                        <if condition="inventoryFacilityId != asset.facilityId">
                            <log level="warn" message="Inventory Facility ${inventoryFacilityId} did not match asset ${asset?.assetId} facility ${asset?.facilityId} reserving for testMachineOrder ${testMachineOrderId} item ${testMachineOrderItemSeqId}"/></if>

                        <set field="quantityToReserve" from="asset.availableToPromiseTotal &gt; checkQuantityRemaining ? checkQuantityRemaining : asset.availableToPromiseTotal"/>
                        <if condition="quantityToReserve &gt; 0.0">
                            <set field="checkQuantityRemaining" from="checkQuantityRemaining - quantityToReserve"/>
                            <script>lockedAssetList.add(asset)</script>
                        </if>
                        <!-- <log level="warn" message="Locked Asset ${asset.assetId} with ATP ${asset.availableToPromiseTotal} for Reservation quantityToReserve=${quantityToReserve}, checkQuantityRemaining=${checkQuantityRemaining}"/> -->
                    </iterate>
                </if>
                <!-- now use other location types or no location -->
                <if condition="checkQuantityRemaining &gt; 0.0">
                    <entity-find entity-name="mantle.product.asset.AssetLocationDetail" list="checkAssetList">
                        <!-- don't lock here, we'll lock records we need individually to avoid contention -->
                        <econdition-object field="baseAssetCond"/>
                        <econdition field-name="ownerPartyId" operator="in" from="ownerPartyIdSet" ignore="assetAllowOtherOwner == 'Y' || !ownerPartyIdSet"/>
                        <econdition field-name="assetPoolId" operator="in" from="assetPoolIdSet" ignore="!assetPoolIdSet" or-null="true"/>
                        <econdition field-name="assetPoolId" operator="is-null" ignore="assetPoolIdSet"/>
                        <!-- only look for Assets with available quantity, to reduce lock contention we'll create new records for negative ATP -->
                        <econdition field-name="availableToPromiseTotal" operator="greater" from="0.0"/>
                        <econdition field-name="assetId" operator="not-in" from="explicitAssetIdList" ignore-if-empty="true"/>
                        <econdition field-name="assetId" operator="not-in" from="skipAssetIds" ignore-if-empty="true"/>
                        <econdition field-name="lotId" operator="in" from="lotsToUse" ignore-if-empty="true"/>
                        <econdition field-name="statusId" value="AstAvailable"/>
                        <econdition field-name="locationTypeEnumId" operator="not-equals" value="FltPick" or-null="true"/>
                        <select-field field-name="${assetOrderBy},assetId"/>
                        <order-by field-name="${assetOrderBy},assetId"/>
                    </entity-find>
                    <!-- <log level="warn" message="checkAssetList find ${checkAssetList_xafind}\nSQL ${checkAssetList_xafind.getQueryTextList()}"/> -->
                    <iterate list="checkAssetList" entry="checkAsset">
                        <if condition="checkQuantityRemaining &lt;= 0.0"><break/></if>
                        <!-- here we do the lock query, check the ATP using the locked value -->
                        <entity-find-one entity-name="mantle.product.asset.Asset" value-field="asset" for-update="true">
                            <field-map field-name="assetId" from="checkAsset.assetId"/></entity-find-one>

                        <!-- TODO 20180503 remove this at some point, added to monitor corner case issue -->
                        <if condition="inventoryFacilityId != asset.facilityId">
                            <log level="warn" message="Inventory Facility ${inventoryFacilityId} did not match asset ${asset?.assetId} facility ${asset?.facilityId} reserving for order ${testMachineOrderId} item ${testMachineOrderItemSeqId}"/></if>

                        <set field="quantityToReserve" from="asset.availableToPromiseTotal &gt; checkQuantityRemaining ? checkQuantityRemaining : asset.availableToPromiseTotal"/>
                        <if condition="quantityToReserve &gt; 0.0">
                            <set field="checkQuantityRemaining" from="checkQuantityRemaining - quantityToReserve"/>
                            <script>lockedAssetList.add(asset)</script>
                        </if>
                        <!-- <log level="warn" message="Locked Asset ${asset.assetId} with ATP ${asset.availableToPromiseTotal} for Reservation quantityToReserve=${quantityToReserve}, checkQuantityRemaining=${checkQuantityRemaining}"/> -->
                    </iterate>
                </if>
            </if>

            <!-- <log level="warn" message="Reserve order ${testMachineOrderId}:${testMachineOrderItemSeqId} asset ${assetId} lockedAssetList: ${lockedAssetList*.assetId} ${lockedAssetList*.availableToPromiseTotal}"/> -->

            <!-- do the reservations... -->
            <set field="baseMap" from="[testMachineOrderId:testMachineOrderId, testMachineOrderItemSeqId:testMachineOrderItemSeqId, productId:productId]"/>
            <iterate list="lockedAssetList" entry="asset">
                <if condition="quantityRemaining &gt; 0.0">
                    <set field="quantityToReserve" from="asset.availableToPromiseTotal &gt; quantityRemaining ? quantityRemaining : asset.availableToPromiseTotal"/>
                    <if condition="quantityToReserve == 0.0"><continue/></if>
                    <set field="quantityRemaining" from="quantityRemaining - quantityToReserve"/>
                    <if condition="quantityToReserve &lt; 0.0">
                        <return error="true" message="In reserve#AssetForTestMachineOrderItem (with assets found) got negative quantityToReserve ${quantityToReserve}"/></if>
                    <service-call name="create#mantle.product.issuance.AssetReservation" out-map="resOut" in-map="baseMap +
                            [assetId:asset.assetId, reservedDate:nowTimestamp, quantity:quantityToReserve,
                                quantityNotAvailable:0.0, quantityNotIssued:quantityToReserve,
                                sequenceNum:asset_index, reservationOrderEnumId:reservationOrderEnumId]"/>
                    <service-call name="create#mantle.product.asset.AssetDetail" in-map="baseMap +
                            [assetId:asset.assetId, effectiveDate:nowTimestamp,
                                availableToPromiseDiff:-quantityToReserve, assetReservationId:resOut.assetReservationId]"/>
                    <!-- <log level="warn" message="Reserved Asset ${asset.assetId} with ATP ${asset.availableToPromiseTotal}, quantityToReserve=${quantityToReserve}, quantityRemaining=${quantityRemaining}"/> -->
                </if>
            </iterate>

            <!-- if Product is a Pick Assembly (productTypeEnumId=PtPickAssembly):
                - reservations may be against PA Product and/or against BOM component Products
                - if any already assembled in stock will have used above
                - instead of not available reservation try to reserve each BOM component
                - if a BOM component does not have sufficient inventory do not available reservation per component
            -->
            <if condition="quantityRemaining &gt; 0.0 &amp;&amp; product.productTypeEnumId == 'PtPickAssembly'">
                <entity-find entity-name="mantle.product.ProductAssoc" list="assocList">
                    <date-filter/>
                    <econdition field-name="productId" from="product.productId"/>
                    <econdition field-name="productAssocTypeEnumId" value="PatMfgBom"/>
                </entity-find>
                <iterate list="assocList" entry="assoc">
                    <if condition="assoc.productId == assoc.toProductId">
                        <return error="true" message="Pick Assembly Product ${assoc.productId} has itself for a component product, remove the Manufacturing BOM Association"/></if>

                    <service-call name="mantle.product.AssetServices.reserve#AssetForTestMachineOrderItem"
                                  in-map="[testMachineOrderId:testMachineOrderId, testMachineOrderItemSeqId:testMachineOrderItemSeqId, productStore:productStore, forceReserve:forceReserve,
                                componentProductId:assoc.toProductId, componentQuantity:((assoc.quantity ?: 1.0) * quantityRemaining)]"/>
                </iterate>

                <set field="quantityRemaining" from="0.0"/>
            </if>

            <if condition="quantityRemaining &gt; 0.0">
                <!-- look for qualifying Asset even if no available quantity and do 'not available' reservation on that instead of creating new ad-hoc -->
                <entity-find entity-name="mantle.product.asset.Asset" list="existingResAssetList" limit="1">
                    <econdition field-name="productId"/>
                    <econdition field-name="facilityId" from="inventoryFacilityId"/>
                    <econdition field-name="ownerPartyId" from="organizationPartyId"/>
                    <econdition field-name="assetPoolId" from="null"/>
                    <econdition field-name="locationSeqId" from="null"/>
                    <econdition field-name="containerId" from="null"/>
                    <econdition field-name="lotId" from="null"/>
                    <!-- may be populated even for negative availability placeholder records: <econdition field-name="acquireCost" from="null"/> -->
                    <econdition field-name="statusId" value="AstAvailable"/>
                    <econdition field-name="hasQuantity" value="Y"/>
                    <econdition field-name="availableToPromiseTotal" operator="less-equals" from="0.0"/>
                    <select-field field-name="assetId"/>
                    <!-- NOTE: order by ATP ascending, expect to be negative so highest negative value first -->
                    <order-by field-name="availableToPromiseTotal"/>
                </entity-find>
                <set field="newResAssetId" from="existingResAssetList ? existingResAssetList.get(0).assetId : null"/>
                <if condition="!newResAssetId">
                    <!-- no asset... create a shell one to record the reservation and detail against -->
                    <service-call name="beiyelin.product.AssetServices.create#ProductAssetAdHoc" out-map="assetOut"
                                  in-map="[productId:productId, facilityId:inventoryFacilityId, ownerPartyId:organizationPartyId,
                                createdDate:nowTimestamp]"/>
                    <set field="newResAssetId" from="assetOut.assetId"/>
                </if>

                <service-call name="create#mantle.product.issuance.AssetReservation" out-map="resOut" in-map="baseMap +
                        [assetId:newResAssetId, reservedDate:nowTimestamp, quantity:quantityRemaining,
                            quantityNotAvailable:quantityRemaining, quantityNotIssued:quantityRemaining,
                            sequenceNum:0,
                            reservationOrderEnumId:reservationOrderEnumId]"/>
                <service-call name="create#mantle.product.asset.AssetDetail" in-map="baseMap +
                        [assetId:newResAssetId, effectiveDate:nowTimestamp,
                            availableToPromiseDiff:-quantityRemaining, assetReservationId:resOut.assetReservationId]"/>
            </if>
        </actions>
    </service>

    <service verb="remove" noun="TestMachineOrderItemReservations">
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <parameter name="testMachineOrderItemSeqId" required="true"/>
        </in-parameters>
        <actions>
            <!-- do a FOR UPDATE query on TestMachineOrderItem as a semaphore -->
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderItem" value-field="testMachineOrderItem" for-update="true"/>

            <entity-find entity-name="mantle.product.issuance.AssetReservation" list="existingResList" for-update="true">
                <econdition field-name="testMachineOrderId"/><econdition field-name="testMachineOrderItemSeqId"/></entity-find>
            <iterate list="existingResList" entry="existingRes">
                <service-call name="mantle.product.AssetServices.reduce#AssetReservation"
                              in-map="[assetReservationId:existingRes.assetReservationId, reserveIncreasedAsset:true]"/>
            </iterate>
        </actions>
    </service>
    <service verb="remove" noun="TestMachineOrderReservations">
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
        </in-parameters>
        <actions>
            <!-- do a FOR UPDATE query on TestMachineOrderItem as a semaphore -->
            <entity-find entity-name="beiyelin.testmachine.TestMachineOrderItem" list="testMachineOrderItemList" for-update="true">
                <econdition field-name="testMachineOrderId"/></entity-find>

            <entity-find entity-name="mantle.product.issuance.AssetReservation" list="existingResList" for-update="true">
                <econdition field-name="testMachineOrderId"/></entity-find>
            <iterate list="existingResList" entry="existingRes">
                <service-call name="mantle.product.AssetServices.reduce#AssetReservation"
                              in-map="[assetReservationId:existingRes.assetReservationId, reserveIncreasedAsset:true]"/>
            </iterate>
        </actions>
    </service>

</services>
